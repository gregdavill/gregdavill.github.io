[{"content":"RTL Architecture The original version of the frame grabbing PCB used an iCE40 HX8K FPGA. This turned out to be a little small for the features I wanted to add. I managed to get it to a state where it would capture images from the Boson 320, but everything was hardwired together, and not easy to alter or reuse.\nIn order to improve module reuse and extendability a standard interface should be used. There are a few of these internal bus architectures available. I‚Äôve decided to use wishbone, Mainly because I‚Äôve been able to find existing wishbone modules that perform most of the major functionality of the frame grabber I‚Äôm building.\n   Components wb_intercon Maybe the most important component. It is a collection of verilog components (mux, arbiter, upscaler, downscaler) and a python script that automatically generates all the required modules instantiations and wiring based on a simple easily human readable configuration file.\nDocumentation is a little bit lacking for this. I had to do a bit of reverse engineering on the python parser to understand the format required of the configuration file. For convenience of anyone else wanting to use this component here is a short description. There are two main configuration types, {master, slave} the master needs to know which slaves it will be connected to. The slaves need a base memory address and a length.\n(Some care needs to be taken to ensure that memory segments do not overlap between slaves)\nA python script takes this config file and creates two files a Verilog file and a Verilog header. This script pre-wires in muxes and arbiters as required if two masters have requested to have access over the same slave.\n[master cpu0] slaves = ram0 [slave ram0] offset=0x00000000 size=0x4000 wb_streamer The streamer translates between a stream interface and wishbone transactions. It supports configurable burst length. The stream interface is extendable to support the data from the camera directly. Which is essentially a parallel stream. Combined with some glue logic and other stream utilities (stream_upsizer, stream_dc_fifo) this makes up the main logic to capture the camera data into RAM.\npicoSoC PicoSoC is a small wrapper around picorv32, a small and robust implementation of the RISCV open source CPU architecture. The wrapper includes a SPI driver to read instruction from a SPI FLASH (typically shared with config memory). A simple UART diver, and an optional wishbone / AXI wrapper. Since the rest of my system is using the wishbone wrapper I am using the wishbone wrapper. Note this CPU does not have the greatest IPC values, so it‚Äôs more targeted as a data-path controller for there higher performance logic in your system.\nSD controller (sdc) This is a complete 1/4bit open source SD controller. It includes a wishbone configuration interface, and a wishbone master to read/write data blocks. The inclusion of the wishbone master is essentially a dedicated DMA.\nAlthough it‚Äôs a complete package I did have to hack around a bit to get it working successfully. I‚Äôll write a more detailed explanation of the changes at some point. But here are the main points.\n  Buggy asynchronous FIFO implementation. Results in occasional buggy data in my testing. If sd_clk \u0026laquo; wbclk then the original writers may not have seen this behavior. Currently I fix this by registering the next word of data. Ideally you would replace the FIFO implementation.\n  No example of how to wire into a system. It‚Äôs essential to output DATA and CMD signals at the negative edge, to ensure that setup/hold timing is satisfied on the SD cards Internal receivers. This is because data is latched on the rising edge. Registering on the neg-edge inside the I/O block is working for me.\n  No sw-driver. I‚Äôve written my own. (work in progress) See my implementation into FatFs here. It is based of the FatFs example targeting a micro controller with real SD hardware (not SPI mode)\n  This full SD controller is a huge improvement of the SPI based design I was using on the old hardware. But there are still many small areas to tweak in order to boost performance.\nHyperRAM My hyperRAM implementation is based off BML‚Äôs great work! I‚Äôve used his PLL example for the Xillinx 7-series. I had to slightly modify timings for working with the DDR modules inside the Lattice ECP5. I‚Äôve also written a basic wrapper and changed the burst read method. This supports wishbone linear bursts assuming that the master issues a request the cycle after an ACK. This is the case for the wb_streamer components, but not achievable with picosoc.\n  I‚Äôve hit a few issues with timing on the hyperRAM bus. For awhile it was working perfectly in hardware but the simulator was failing. If I adjusted the code to work on the simulator then the hardware would fail. I think I have tracked this down after drawing out a diagram of the signal timings.\nWhen reading data from the HyperRAM the signals operate in ‚ÄúAligned‚Äù fashion. But there is a delay of up to 5.5ns in the output of this data from the previous clock edge. I was attempting to sample this signal with Sys_clk which edges should be 5.2ns BEFORE the HyperBus clock. This also explains why my simulation was failing.\nCMOS Capture Controller (ccc) This is a module that I have written. It consists of a set of wishbone registers, and logic that operates with the Camera Clock. The main function of this module is to support gating the data stream using v-sync to support capturing a complete frame. Due to it‚Äôs position in the design I have started to add new features into this module. including clocks_per_frame, pixels_per_frame, total_frames_seen.\npixels per frame enables the hardware to automatically determine which model of camera is connected a 320 or 640 model.\n Current ECP5 Logic usage With all the modules mentioned above I am just over the 12K LUT usage of the ECP5. This is about half of the total available resources. So I think I made a good choice using the ECP5-25F instead of the slightly cheaper ECP5-12F*\n  Update:\n*The ECP5 is actually contains 25k LUTs inside, there is no 12k die. When making use of the Yosys/NextPnR all 25k LUTs are available\n ","permalink":"https://gregdavill.github.io/posts/boson-frame-grabber-pt5/","summary":"RTL Architecture The original version of the frame grabbing PCB used an iCE40 HX8K FPGA. This turned out to be a little small for the features I wanted to add. I managed to get it to a state where it would capture images from the Boson 320, but everything was hardwired together, and not easy to alter or reuse.\nIn order to improve module reuse and extendability a standard interface should be used.","title":"Boson Frame Grabber Part 5"},{"content":"The new hardware for the Boson Frame Grabber will be based around the Lattice ECP5 family. Lattice make available a free IDE for this FPGA assuming you are not using a model with embedded SERDES. Since we are not, it\u0026rsquo;s perfect for our application.\nThe ECP5 is classified as a high-performance low power FPGA. there are variants available with 2.5/5Gb/s SERDES. The biggest feature for this application is it is available in a 8x8mm 285pin csBGA package. Additionally, the ECP5 is available in 12K,25K,45K,85K LUT variants. Given that my last design was approaching 8K LUTs, I suspect a design will fit in 12K. But the minimal price increase for the 25K variant makes it a pretty good choice.\n    Design   The design PCB layout of this new version is derived from the v1_01. With the following changes:\n Switched out the iCE40HX for an ECP5 in csBGA 285 package. Changed the LDOs. Now separate tiny LDOs for each 1.1, 1.8, 2.5v supplies.  The HyperRAM, FLASH, IO level-shifters, JTAG points, Oscillator are all the same. I\u0026rsquo;m still using the altered footprint for the Boson connector, this definitely helps with routing. The extra width from the ECP5 and the extra pins along the top also help with routing the 16bit parallel bus from the camera into the FPGA.\nYou can see the updated FPGA page of the schematic below. I\u0026rsquo;m using around 60 out of the 118 available PIO pins on this package. I tried to constrain high-speed buses like the SD card and HyperRAM to their own bank. But I don\u0026rsquo;t think that\u0026rsquo;s particularly important at the speeds I\u0026rsquo;m working within this design. What is important is ensuring that devices connected to a particular bank are at the right IOVDD level.\n  We have 2 different IO voltages in this design\n 1.8V - HyperRAM, Boson, Oscillator, I/O 3.3V - SDMMC, FLASH  Because I had specifically used level-shifting Tri-stateable Buffers for the two external IO ports, I\u0026rsquo;m easily able to control them from a 1.8V IO bank.\n  The main reason for using these buffers is to ensure that the low voltage sensitive IO pins of the FPGA are somewhat protected from external signals, The buffers used are SN74LVC1T45\u0026rsquo;s They will tolerate voltages up to 7V and retain their high-impedance state even when they are not powered.\nWith these Tri-stable buffers, it\u0026rsquo;s often useful to write on your schematic what the DIR pin actually does. Often they can take an inverted input. Writing this stuff on a schematic it is a lot easier to see than pulling up the datasheet again if you forget or want to double check.\n  I\u0026rsquo;ll mention the LDOs I used again. I used TLV733P parts, but it\u0026rsquo;s a jelly bean part available from many different manufacturers. The package I need is the XSON style 1x1mm package, very challenging to solder. But the small size is essential to fitting everything on my 21x21mm PCB. For reference, the capacitors next the regulators between are 0402!! Yes, they\u0026rsquo;re small. I\u0026rsquo;ve seen raw sugar crystals bigger than these regulators.      Check Leadtimes (I designed a v1_03 PCB) One thing I did not check until after I had ordered wy PCBs was the availability of the ECP5 in csBGA 285 package. It turns out there was either a bit of a shortage, or it\u0026rsquo;s not a standard stocking part. Lattice lists an 8 week lead time, luckily from lattice you can buy singles with this lead time for prototypes. But from some distributors request you order an entire tray or 168 parts!\nBecause I was impatient, I decided to create a testing board using an in-stock package of the part. Here is that board. I made it bigger to support an LCD screen.\n    This board is v1_03 in the github project. But it has an errata list longer than my arm. All caused by rushing the design over one weekend. I managed to get it mostly working, but it will never support auto-configuration from FLASH. So in order to run it, you are required to load a bitstream through JTAG.\nWhat ended up happening is that the day I assembled this prototype big-board, I found that Lattice had stock of one variant of the ECP in csBGA 285 package. This ended up being around 2 weeks out of the quoted 8 weeks lead time.\nv1_02 (But this time with parts) With parts in hand, the assembly proceeded without a hitch. I made use of a stencil from OSH Stencils. This is the first time I\u0026rsquo;ve attempted this. But I added holes to my edge rails on my PCB panel, and spec\u0026rsquo;d corresponding holes in the stencil. Using some small Steel pins makes stencil alignment PERFECT!\n  When I designed the iCE40 Version I thought I had packed the PCB, but this is even denser. I\u0026rsquo;m very proud of my efforts to design this board and still remain within a \u0026ldquo;standard\u0026rdquo; PCB 4 layer process.\nI am still hand-assembling the rear-side components. Just use lots of flux, and a fine tipped iron with a flat edge. Lastly, a family shot of v1_01 next to its superior v1_02 hardware.\n      In the next part I\u0026rsquo;ll finally describe the firmware* design. Hopefully, I can this hardware to work. (Even if doesn\u0026rsquo;t work, it looks great!)\n(*Is Verilog firmware? That\u0026rsquo;s something I\u0026rsquo;m not clear about.)\n  Update:\nI\u0026rsquo;ve been informed that RTL is often referred to as \u0026ldquo;Gateware\u0026rdquo;. Which seems quite fitting\n","permalink":"https://gregdavill.github.io/posts/boson-frame-grabber-pt4/","summary":"\u003cp\u003eThe new hardware for the Boson Frame Grabber will be based around the Lattice ECP5 family. Lattice make available a free IDE for this FPGA assuming you are not using a model with embedded SERDES. Since we are not, it\u0026rsquo;s perfect for our application.\u003c/p\u003e","title":"Boson Frame Grabber Part 4"},{"content":"In this part I want to talk about the firmware, or code, this device will need in order to operate as I want.\nBut before I get to that lets take a quick step backwards to some back of the envelope engineering I did when I was thinking about the hardware required to save an image from the camera.\nData Flow The Boson is designed to stream images out automatically, the camera has a control interface, but you cannot simply ask it to \u0026ldquo;snap\u0026rdquo; a photo, and read it out byte by byte. Instead it just rudely spews out data. It has a 16bit bus running with a 13.5MHz pixel clock. This equates to a bus speed of 27MByte/s. Luckily for us pixel data on this bus comes in bursts, before and after each line of valid data there is a gap and after every line in a frame has been transmitted there is a few lines blank. These are Horizontal and vertical blanking periods designed to give electronics some time to process the information. (My understanding is that originally these were to give CRT screens time to energize coils and steer the electron beam back to be ready for the start of the next row. But they are still common place in many video formats.)\n  I decided to add high speed RAM to the design in order to ensure I could reliably capture the video frame. I have used SD cards in the past and it is pretty common place for them to have variable delays when writing data blocks to them as they perform various internal operations. If I could get away with bypassing the RAM in the final design great, but I still wanted it in the hardware.\nOne benefit of using the RAM is that it doesn\u0026rsquo;t matter what speed the SD card is running at this makes life easier. I can develop the modules that are needed to run the system then leave as much optimization till the end.\nVerilog \u0026amp; PicoSoC Code that describes hardware. As mentioned this is my first FPGA project. I had already selected the iCE40HX8K as it was the largest ICE40 in the smallest package. This particular FPGA has 8k LUTs. I didn\u0026rsquo;t know how many LUTs my design would require. Is 8k alot? What is a LUT? I\u0026rsquo;m not going to go into FPGA basics, but from my experience 8k is enough to implement a RISCV 32 bit processor and a handful of basic peripherals. It is enough to get your feet wet in a real FPGA project!\n  I had chosen the ICE40 as a target device because I was reading about a free open source FPGA tool-chain ice-storm. I followed the guides and examples and got a LED blinking on the back of my board! This project was on it\u0026rsquo;s feet. But I was still a bit outside my comfort zone.\nClaire Xen is the creator of the icestorm project. She also created a lightweight RISCV processor called picorv32. More importantly for me (A verilog newbie) she packaged this into PicoSoC.\n  PicoSoC is a combination of the RISCV CPU picorv32, a flash memory controller for reading in program data, some SRAM, and a UART serial port. Also an example built on the Lattice HX8K evaluation board! The processor let you write C code and using memory mapped register directly control and monitor bits in your custom hardware. it was a perfect way for me to ease into FPGA design. PicoSoC has some great step by step instructions in order to compile and get it loaded, one of the steps is downloading and compiling a RISCV variant of GCC. This went smoothly but was the slowest port (~4 hours on my slow laptop.) The wait was worth it, because after it finished I had PicoSoC loaded and running on my custom hardware. The UART link to the PC gives you a very simple text console which I think is perfect for adding to and modifying in firmware. (Love the PicoSoC splash screen btw Clifford!)\nThink Modular   Verilog is constructed as a very hierarchical language. Which means when developing systems for FPGAs you should be thinking about modules, how can you split your design into modular blocks that fit together. I envisioned a system as shown above, I had now validated that the FPGA was functioning, SPI FLASH and programming worked, and my User I/O and LED worked. I wanted to write some logic to test the SD card, HyperRAM, and Boson Interface. Any of these could have a hardware bug in the PCB design that could render this prototype useless.\nBoson IF I wrote the Boson Interface first as a basic FIFO, using commands in the SoC\u0026rsquo;s firmware I was able to reset the FIFO and print out 16 values that had appeared from the camera over serial. This with a combination of holding my hand in front of the camera indicated that data was been read correctly from the camera.\nHyperRAM I had started working on a hyperRAM module with my first prototype hardware. However I didn\u0026rsquo;t really understand what interfaces I would need to support the burst style data that the RAM needs in order to sustain it\u0026rsquo;s read speeds. At this time I saw Kevin Hubbard from Black Mesa labs had just released an open source HyperRAM library, His library relies on dividing the clock rate by 4 to properly generate the DDR signal timings without having to worry about device specific PLLs. With a bit of reading though his very well documented code I was able to add his module to the PicoSoC system bus and test the RAM using some simple functions in C.\nMicro SD \u0026amp; FAT   The biggest benefit of using a softcore processor in my design in my opinion was the ability to leverage existing open source software projects. FatFs is one of those projects, I\u0026rsquo;ve used it on countless projects in the past. The example projects include a \u0026ldquo;barebones\u0026rdquo; implementation of the low level control using bit-banged IO. In order to get this to work I just had to extend the GPIO registers from write only to R/W and map them to the SD card pinout in verilog. With those small changes* I was able to write a file to the SD card!\n*I spent an entire evening scratching my head as to why FatFs wasn\u0026rsquo;t working. As soon as I looked at the memory-map output from GCC I worked out why, I think one of the goals of PicoSoC is to be simple enough to get up and running fast. Because of this the example firmware (what my code was based off) only utilized the RAM on the stack, the linker never declared where to store static/global variables, and the startup code never initialized these. I did a few unspeakable linker-hacks to get it to work initally. A better solution is to use the code provided by Miodrag Milanoviƒá, Who did a great job porting microPython to the picoSoC.\nPick Your Battles Now with each hardware component tested to be working I knew the hardware should be capable of capturing an image from the camera, I just had to tell it how to do it.\n  My idea for a simple capture sequence is as follows:\n On powerup Boson IF module has control over the HyperRAM. The CPU tries to access the HyperRAM and becomes stalled. The Boson IF waits for a Vsync pulse to synchronize with the image. It captures an image through a Dual-clock FIFO. (Boson Camera Controls the pixel clock) A small state-machine empties the FIFO. After 3202562 bytes the state-machine in Boson IF releases the HyperRAM. CPU takes over and using FatFS writes an image to the SD card.    To my surprise this worked! Not ideal though, you had to restart the camera to take a new photo, the SD card was still slow, and it would over-write the last photo you took.\n   You can see a few errors with this photo, firstly I miss-judged what the focal distance would see. There is a 2 pixel band on the left image that\u0026rsquo;s actually pixels from start of the next line. I messed up the endian-ness so every pair of pixels is flipped. Still a success!!  Optimise When Ready I systematically went through and added performance to each module.\n HyperRAM got updated to make use of the DDR IO and PLL in the ICE40. SD driver got updated to a hardware SPI module running at 12MHz. Control registers added to the Boson IF to enable capture through the picoSoC terminal. Lastly I added a simple DMA to copy data from the HyperRAM out into the SD card without requiring the CPU. This greatly improved performance.  I reduced the time to save an 320x256 image from ~12s to ~0.3s.\nMoving Forward At this point I\u0026rsquo;ve run out of space inside the ICE40HX8K. I\u0026rsquo;m sure there is room to optimise the current design, but it is very difficult to add extra features. In order to push the performance even further I will need to swap the SD SPI driver for a real SD 4-bit interface. There are a few open source versions but none of them fit. Time to look for a bigger FPGA?\n  Up to this point I had I had been working with a Boson 320x256 9Hz I\u0026rsquo;ve borrowed from work. GroupGets a FLIR distributor among other things offered to send me a Boson 640x512 60Hz model! Amazing! If you\u0026rsquo;re interested in picking up a Boson Camera check out their range!\n  Unfortunately the Camera running at 60Hz outputs data too fast for the logic in my HX8K board to keep up with. It\u0026rsquo;s pixel clock is 27MHz at 60Hz which corresponds to a 54MByte/s bus speed. The FIFO can capture this but my HyperRAM bus is not able to sustain a data rate to be ready by the next line. But by enabling the average in the camera the frame rate is reduced to 30Hz and the clock brought down to 13.5MHz, with some small tweaks I was able to capture this frame. (95 degree FOV is VERY wide!)\n  I have plans to create an updated version featuring a more power processor capable of handling both the Boson 320 and Boson 640. Stay tuned for more details about this in Part 4!\nHere is a teaser! üòâ\n   ","permalink":"https://gregdavill.github.io/posts/boson-frame-grabber-pt3/","summary":"\u003cp\u003eIn this part I want to talk about the firmware, or code, this device will need in order to operate as I want.\u003c/p\u003e","title":"Boson Frame Grabber Part 3"},{"content":"In part 1, I discussed the version 1 prototype I had built. Just after ordering the PCBs for that project I decided to start thinking about miniaturizing the hardware.\n   If I could integrate more parts into the FPGA I could reduce the BOM and PCB area required for the entire device. I was still looking at the iCE40 family and discovered the iCE40HX8K came in a 0.5mm BGA 8x8mm. This was small enough to fit directly behind the camera core!! (Notice the pocket on the back of the camera casting, it\u0026rsquo;s just over 1mm deep)\nDesign        The design revolves around the two main ICs, the FPGA, and the HyperRAM. These were placed on the PCB behind the camera. The connector for the camera with the same custom footprint enabled all the camera signals to be routed out on a single layer, the use of an FPGA also helped here, as most of the time you can simply swap pins to help with routing.\nThe FPGA is now responsible for handling the SD logic, I routed the signals required for 4bit SD mode, this can also be used in SPI mode by the FPGA. Starting with SPI mode should make this easier to bring up the firmware.\nThe device features 2 user I/O. these run through a bidirectional level converter, and TVS. My thoughts here is that this will make the I/O much more robust as the level converters I\u0026rsquo;m using will easily handle input voltages of 6-7V without complaint, the same can not be said for the FPGA.\nThe RAM used here is the same HyperRAM as v1 prototype. 64Mbit DRAM with a 12pin HyperBus interface. I used a tiny 8Mbit QSPI Flash in 8 pin 2x3 USON package. and a JTAG interface on the back of the device which makes use of pogopins.\nFT232H programmer    I was going to have to develop my own programmer, fortunately Piotr had already built this great FT232H multitool! I was able to use his design and simply create my own adapter PCB!\nHardware   PCBs arrived from OSHPark. I haven\u0026rsquo;t used OSHPark for PCBs since it was Laen\u0026rsquo;s group PCB. (and the boards were still blue. :S ). But they are great quality, which should be expected. I ordered both the FT232H multitool design, a pogopin breakout, and my new Boson Frame Grabber PCB.\nI had ordered a PCB from OSHPark before I discovered the hyperRAM footprint error on my last PCB, so unfortunately the main PCB was useless (what are you gonna do). I was able to use the programmer, and I used the PCB for BGA practice! (I shorted a few pins on this attempt, so well worth it). Speaking of OSHPark PCBs damn do they look nice! That LPI silkscreen process really shines!\n    Hardware Take 2   I had already ordered some new PCBs from JLCPCB.com after correcting the footprint of the HyperRAM. These boards showed up within about a week of ordering, this is of course using DHL (Otherwise your PCBs typically spend a few weeks in the mail system).\n  The PCBs from JLCPCB look great! this was the first time I used their service. Their manufacturing specs are very impressive for the price! I\u0026rsquo;ll definitely be using their service again! Although this is only a prototype run, given the size of my PCBs I decided to create a small panel using the GerberPanelizer tool (http://blog.thisisnotrocketscience.nl/projects/pcb-panelizer/)\nThis worked out great! JLCPCB did not have any issue routing out the space between boards. (I kept around 2mm between PCBs.)\n      I soldered up a single PCB by hand, this is time consuming, but forces you to relax. (If you\u0026rsquo;re not relaxed while placing small parts with tweezers they tend to fling out and shoot across the room :S ). Again hot-air and flux. You can never have too much flux, I use AMTECH NC-559-V2-TF that I buy in large 30cc tubes that you can pickup from Louis Rossmann.\n  After assembly I really didn\u0026rsquo;t expect it to work, this is the first time I\u0026rsquo;ve soldered a 0.5mm BGA by hand, and you can\u0026rsquo;t be sure that it\u0026rsquo;s correctly soldered unless you use expensive x-ray inspection tools, or destructive methods (that would destroy your prototype). I connected up my homemade programmer and powered on the board with 3.3V from my bench power supply. It worked!\nA little verilog code later, tinkering with examples found online I managed to have a compiled bitstream that would flash a LED. The LED started flashing. ^_^\n    The LED blinks? Now what?\nPart 3 will take a look a the verilog and firmware required to get this thing up and running. Check it out here\n","permalink":"https://gregdavill.github.io/posts/boson-frame-grabber-pt2/","summary":"\u003cp\u003eIn part 1, I discussed the version 1 prototype I had built. Just after ordering the PCBs for that project I decided to start thinking about miniaturizing the hardware.\u003c/p\u003e","title":"Boson Frame Grabber Part 2"},{"content":"Background   FLIR has recently released a new OEM thermal Camera core. The Boson. These cores are self contained units that handle all the complexities of thermal imaging. They contain the thermal image sensor itself, a NUC/FFC shutter, and a lens assembly capable of focusing thermal energy. They also contain control electronics that present a standard CMOS style image sensor parallel interface. (DATA + CLK + HSYNC/VSYNC).\n  Having used the previous Thermal core from FLIR (The Tau 2) at work in project, our local distributor sent us some Boson cores to have around for integration. These unfortunately sat on our shelf for a few months. I wanted to learn how to design projects with FPGAs, so I decided to create an FPGA based product to capture the data stream from the Boson core into a usable format.\nDesign   Prototype v1 This is my very first FPGA project, I had used FPGAs before in a uni class on Digital Electronics. I had also learnt about the RISCV CPU architecture in Computer Architecture. But had never designed an FPGA into a project. I had just listened to an episode of the Amp Hour with Clifford Wolf, explaining the Lattice iCE40 open source toolchain: icestorm. So naturally I started there. (Also Naturally I picked the only variant in the iCE40 family that is not compatible with icestom. Still supported by lattices' tools.)\n  I crawled through the datasheets for the iCE40 Family and the variant I picked the iCE5LP4K, this was available in an easy to solder QFN 48. I decided to \u0026ldquo;simplify\u0026rdquo; the FPGA work by basically creating a large FIFO. This would capture a frame from the high speed datastream of the camera into some external RAM, then a microcontroller could read this data at its own pace and save it to an SD card. This probably would have worked, but I never developed the code for this completely. I had already started developing v2 with a larger FPGA on a smaller PCB. That will be talked about in part 2.\nThe RAM I chose was 64Mbit of hyperRAM. HyperRAM is self refreshing DRAM, which is refered to as Pseudo SRAM (PSRAM). This provides the high density benefits of DRAM with the simplicity of SRAM. It uses a 12 wire Interface bus which uses a 8bit DDR data bus and control signals. Due to its nature it\u0026rsquo;s a champ at long bursts of data. Perfect for the streamed data from the camera.\nI chose the SAMD51 as a microcontroller to handle the SD + FAT stuff mostly because I had just used them in another project. :) But they do feature a true SDMMC 4 bit interface which is essential to get any decent performance from an SD card.\nHardware Assembly   This is the part of a project I enjoy the most. I was able to hand assemble this prototype with a soldering iron and a hot air setup. (Tip: use lots of flux). The PCBs arrived from PCBWay, I had all my parts from Mouser/Digikey, I was ready to assemble.\nSome comically small parts on this board are these voltage regulators, They are adjustable dual LDOs, I used 0603 caps/resistors which individually are almost larger than the chip. Still an easy job to assemble with the right tools and some practice.\n  One interesting point of this prototype was the discovery I could make a custom footprint for the connector in KiCad, this custom version removes alot of pins that are unused in this application. This enables me to route out the signals all on the top layer. Because these pins may still have a voltage/signal present on them it is essential that a soldermask is present underneath the repurposed pins.\n    Firmware I designed the FPGA to be configured through a slave device of the samd51. This took too long to get working, by the time I had it working and had started working on the verilog the new prototype had arrived, and I decide to leave this project. It had served as a great first step in getting started with FPGAs and had given me added confidence with the tools and workflow.\nHowever I did develop a simple hyperRAM interface in a verilog simulator, when I tried it on the real hardware I discovered a serious bug\u0026hellip;\n  Errata In my haste to develop an entire PCB with new components. I had mislabelled the coordinates on the BGA footprint. This required me to perform the following rework. Surprisingly this does actually work. My code that tested this was only running at 12MHz bus speed. But I\u0026rsquo;m still impressed with my own job. I did this without the aid of a microscope (I have since bought a microscope.)\n In Part 2 I take a look at the hardware behind version 2 prototype!\n","permalink":"https://gregdavill.github.io/posts/boson-frame-grabber-pt1/","summary":"Background   FLIR has recently released a new OEM thermal Camera core. The Boson. These cores are self contained units that handle all the complexities of thermal imaging. They contain the thermal image sensor itself, a NUC/FFC shutter, and a lens assembly capable of focusing thermal energy. They also contain control electronics that present a standard CMOS style image sensor parallel interface. (DATA + CLK + HSYNC/VSYNC).\n  Having used the previous Thermal core from FLIR (The Tau 2) at work in project, our local distributor sent us some Boson cores to have around for integration.","title":"Boson Frame Grabber Part 1"}]