[{"content":"Background   \n  FLIR has recently released a new OEM thermal Camera core. The Boson. These cores are self contained units that handle all the complexities of thermal imaging. They contain the thermal image sensor itself, a NUC/FFC shutter, and a lens assembly capable of focusing thermal energy. They also contain control electronics that present a standard CMOS style image sensor parallel interface. (DATA + CLK + HSYNC/VSYNC).\n  \n  Having used the previous Thermal core from FLIR (The Tau 2) at work in project, our local distributor sent us some Boson cores to have around for integration. These unfortunately sat on our shelf for a few months. I wanted to learn how to design projects with FPGAs, so I decided to create an FPGA based product to capture the data stream from the Boson core into a usable format.\nDesign   \n  Prototype v1 This is my very first FPGA project, I had used FPGAs before in a uni class on Digital Electronics. I had also learnt about the RISCV CPU architecture in Computer Architecture. But had never designed an FPGA into a project. I had just listened to an episode of the Amp Hour with Clifford Wolf, explaining the Lattice iCE40 open source toolchain: icestorm. So naturally I started there. (Also Naturally I picked the only variant in the iCE40 family that is not compatible with icestom. Still supported by lattices' tools.)\n  \n  I crawled through the datasheets for the iCE40 Family and the variant I picked the iCE5LP4K, this was available in an easy to solder QFN 48. I decided to \u0026ldquo;simplify\u0026rdquo; the FPGA work by basically creating a large FIFO. This would capture a frame from the high speed datastream of the camera into some external RAM, then a microcontroller could read this data at its own pace and save it to an SD card. This probably would have worked, but I never developed the code for this completely. I had already started developing v2 with a larger FPGA on a smaller PCB. That will be talked about in part 2.\nThe RAM I chose was 64Mbit of hyperRAM. HyperRAM is self refreshing DRAM, which is refered to as Pseudo SRAM (PSRAM). This provides the high density benefits of DRAM with the simplicity of SRAM. It uses a 12 wire Interface bus which uses a 8bit DDR data bus and control signals. Due to its nature it\u0026rsquo;s a champ at long bursts of data. Perfect for the streamed data from the camera.\nI chose the SAMD51 as a microcontroller to handle the SD + FAT stuff mostly because I had just used them in another project. :) But they do feature a true SDMMC 4 bit interface which is essential to get any decent performance from an SD card.\nHardware Assembly   \n  This is the part of a project I enjoy the most. I was able to hand assemble this prototype with a soldering iron and a hot air setup. (Tip: use lots of flux). The PCBs arrived from PCBWay, I had all my parts from Mouser/Digikey, I was ready to assemble.\nSome comically small parts on this board are these voltage regulators, They are adjustable dual LDOs, I used 0603 caps/resistors which individually are almost larger than the chip. Still an easy job to assemble with the right tools and some practice.\n  \n  One interesting point of this prototype was the discovery I could make a custom footprint for the connector in KiCad, this custom version removes alot of pins that are unused in this application. This enables me to route out the signals all on the top layer. Because these pins may still have a voltage/signal present on them it is essential that a soldermask is present underneath the repurposed pins.\n  \n    \n  Firmware I designed the FPGA to be configured through a slave device of the samd51. This took too long to get working, by the time I had it working and had started working on the verilog the new prototype had arrived, and I decide to leave this project. It had served as a great first step in getting started with FPGAs and had given me added confidence with the tools and workflow.\nHowever I did develop a simple hyperRAM interface in a verilog simulator, when I tried it on the real hardware I discovered a serious bug\u0026hellip;\n  \n  Errata In my haste to develop an entire PCB with new components. I had mislabelled the coordinates on the BGA footprint. This required me to perform the following rework. Surprisingly this does actually work. My code that tested this was only running at 12MHz bus speed. But I\u0026rsquo;m still impressed with my own job. I did this without the aid of a microscope (I have since bought a microscope.)\n In Part 2 I take a look at the hardware behind version 2 prototype!\n","permalink":"https://gregdavill.github.io/posts/boson-frame-grabber-pt1/","summary":"Background   \n  FLIR has recently released a new OEM thermal Camera core. The Boson. These cores are self contained units that handle all the complexities of thermal imaging. They contain the thermal image sensor itself, a NUC/FFC shutter, and a lens assembly capable of focusing thermal energy. They also contain control electronics that present a standard CMOS style image sensor parallel interface. (DATA + CLK + HSYNC/VSYNC).","title":"Boson Frame Grabber Part 1"},{"content":"In part 1, I discussed the version 1 prototype I had built. Just after ordering the PCBs for that project I decided to start thinking about miniaturizing the hardware.\n   \n  If I could integrate more parts into the FPGA I could reduce the BOM and PCB area required for the entire device. I was still looking at the iCE40 family and discovered the iCE40HX8K came in a 0.5mm BGA 8x8mm. This was small enough to fit directly behind the camera core!! (Notice the pocket on the back of the camera casting, it\u0026rsquo;s just over 1mm deep)\nDesign    \n    \n    \n  The design revolves around the two main ICs, the FPGA, and the HyperRAM. These were placed on the PCB behind the camera. The connector for the camera with the same custom footprint enabled all the camera signals to be routed out on a single layer, the use of an FPGA also helped here, as most of the time you can simply swap pins to help with routing.\nThe FPGA is now responsible for handling the SD logic, I routed the signals required for 4bit SD mode, this can also be used in SPI mode by the FPGA. Starting with SPI mode should make this easier to bring up the firmware.\nThe device features 2 user I/O. these run through a bidirectional level converter, and TVS. My thoughts here is that this will make the I/O much more robust as the level converters I\u0026rsquo;m using will easily handle input voltages of 6-7V without complaint, the same can not be said for the FPGA.\nThe RAM used here is the same HyperRAM as v1 prototype. 64Mbit DRAM with a 12pin HyperBus interface. I used a tiny 8Mbit QSPI Flash in 8 pin 2x3 USON package. and a JTAG interface on the back of the device which makes use of pogopins.\nFT232H programmer    \n  I was going to have to develop my own programmer, fortunately Piotr had already built this great FT232H multitool! I was able to use his design and simply create my own adapter PCB!\nHardware   \n  PCBs arrived from OSHPark. I haven\u0026rsquo;t used OSHPark for PCBs since it was Laen\u0026rsquo;s group PCB. (and the boards were still blue. :S ). But they are great quality, which should be expected. I ordered both the FT232H multitool design, a pogopin breakout, and my new Boson Frame Grabber PCB.\nI had ordered a PCB from OSHPark before I discovered the hyperRAM footprint error on my last PCB, so unfortunately the main PCB was useless (what are you gonna do). I was able to use the programmer, and I used the PCB for BGA practice! (I shorted a few pins on this attempt, so well worth it). Speaking of OSHPark PCBs damn do they look nice! That LPI silkscreen process really shines!\n  \n    \n  Hardware Take 2   \n  I had already ordered some new PCBs from JLCPCB.com after correcting the footprint of the HyperRAM. These boards showed up within about a week of ordering, this is of course using DHL (Otherwise your PCBs typically spend a few weeks in the mail system).\n  \n  The PCBs from JLCPCB look great! this was the first time I used their service. Their manufacturing specs are very impressive for the price! I\u0026rsquo;ll definitely be using their service again! Although this is only a prototype run, given the size of my PCBs I decided to create a small panel using the GerberPanelizer tool (http://blog.thisisnotrocketscience.nl/projects/pcb-panelizer/)\nThis worked out great! JLCPCB did not have any issue routing out the space between boards. (I kept around 2mm between PCBs.)\ncould not find image   \n    \n  I soldered up a single PCB by hand, this is time consuming, but forces you to relax. (If you\u0026rsquo;re not relaxed while placing small parts with tweezers they tend to fling out and shoot across the room :S ). Again hot-air and flux. You can never have too much flux, I use AMTECH NC-559-V2-TF that I buy in large 30cc tubes that you can pickup from Louis Rossmann.\n  \n  After assembly I really didn\u0026rsquo;t expect it to work, this is the first time I\u0026rsquo;ve soldered a 0.5mm BGA by hand, and you can\u0026rsquo;t be sure that it\u0026rsquo;s correctly soldered unless you use expensive x-ray inspection tools, or destructive methods (that would destroy your prototype). I connected up my homemade programmer and powered on the board with 3.3V from my bench power supply. It worked!\nA little verilog code later, tinkering with examples found online I managed to have a compiled bitstream that would flash a LED. The LED started flashing. ^_^\n  \n    \n  The LED blinks? Now what?\nPart 3 will take a look a the verilog and firmware required to get this thing up and running. Check it out here\n","permalink":"https://gregdavill.github.io/posts/boson-frame-grabber-pt2/","summary":"\u003cp\u003eIn part 1, I discussed the version 1 prototype I had built. Just after ordering the PCBs for that project I decided to start thinking about miniaturizing the hardware.\u003c/p\u003e","title":"Boson Frame Grabber Part 2"}]