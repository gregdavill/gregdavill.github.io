<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Boson Frame Grabber Part 5 | Greg Davill's Projects</title><meta name=keywords content="boson,boson-frame-grabber,thermal"><meta name=description content="Details about the SoC architecture in the Boson Frame Grabber"><meta name=author content><link rel=canonical href=https://gregdavill.github.io/posts/boson-frame-grabber-pt5/><link crossorigin=anonymous href=/assets/css/stylesheet.min.4de95027235e322de5b213f35cb7316180b0d9491605b4af7c4c3a1eb3dcb90a.css integrity="sha256-TelQJyNeMi3lshPzXLcxYYCw2UkWBbSvfEw6HrPcuQo=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5+kdJvBz5iKbt6B5PJI=" onload=hljs.initHighlightingOnLoad()></script><link rel=icon href=https://gregdavill.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://gregdavill.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://gregdavill.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://gregdavill.github.io/apple-touch-icon.png><link rel=mask-icon href=https://gregdavill.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.83.0"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="Boson Frame Grabber Part 5"><meta property="og:description" content="Details about the SoC architecture in the Boson Frame Grabber"><meta property="og:type" content="article"><meta property="og:url" content="https://gregdavill.github.io/posts/boson-frame-grabber-pt5/"><meta property="og:image" content="https://gregdavill.github.io/images/IMG_5073.JPG"><meta property="article:section" content="posts"><meta property="article:published_time" content="2018-11-03T00:00:00+00:00"><meta property="article:modified_time" content="2018-11-03T00:00:00+00:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://gregdavill.github.io/images/IMG_5073.JPG"><meta name=twitter:title content="Boson Frame Grabber Part 5"><meta name=twitter:description content="Details about the SoC architecture in the Boson Frame Grabber"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://gregdavill.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Boson Frame Grabber Part 5","item":"https://gregdavill.github.io/posts/boson-frame-grabber-pt5/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Boson Frame Grabber Part 5","name":"Boson Frame Grabber Part 5","description":"Details about the SoC architecture in the Boson Frame Grabber","keywords":["boson","boson-frame-grabber","thermal"],"articleBody":"RTL Architecture The original version of the frame grabbing PCB used an iCE40 HX8K FPGA. This turned out to be a little small for the features I wanted to add. I managed to get it to a state where it would capture images from the Boson 320, but everything was hardwired together, and not easy to alter or reuse.\nIn order to improve module reuse and extendability a standard interface should be used. There are a few of these internal bus architectures available. I’ve decided to use wishbone, Mainly because I’ve been able to find existing wishbone modules that perform most of the major functionality of the frame grabber I’m building.\n   Components wb_intercon Maybe the most important component. It is a collection of verilog components (mux, arbiter, upscaler, downscaler) and a python script that automatically generates all the required modules instantiations and wiring based on a simple easily human readable configuration file.\nDocumentation is a little bit lacking for this. I had to do a bit of reverse engineering on the python parser to understand the format required of the configuration file. For convenience of anyone else wanting to use this component here is a short description. There are two main configuration types, {master, slave} the master needs to know which slaves it will be connected to. The slaves need a base memory address and a length.\n(Some care needs to be taken to ensure that memory segments do not overlap between slaves)\nA python script takes this config file and creates two files a Verilog file and a Verilog header. This script pre-wires in muxes and arbiters as required if two masters have requested to have access over the same slave.\n[master cpu0] slaves = ram0 [slave ram0] offset=0x00000000 size=0x4000 wb_streamer The streamer translates between a stream interface and wishbone transactions. It supports configurable burst length. The stream interface is extendable to support the data from the camera directly. Which is essentially a parallel stream. Combined with some glue logic and other stream utilities (stream_upsizer, stream_dc_fifo) this makes up the main logic to capture the camera data into RAM.\npicoSoC PicoSoC is a small wrapper around picorv32, a small and robust implementation of the RISCV open source CPU architecture. The wrapper includes a SPI driver to read instruction from a SPI FLASH (typically shared with config memory). A simple UART diver, and an optional wishbone / AXI wrapper. Since the rest of my system is using the wishbone wrapper I am using the wishbone wrapper. Note this CPU does not have the greatest IPC values, so it’s more targeted as a data-path controller for there higher performance logic in your system.\nSD controller (sdc) This is a complete 1/4bit open source SD controller. It includes a wishbone configuration interface, and a wishbone master to read/write data blocks. The inclusion of the wishbone master is essentially a dedicated DMA.\nAlthough it’s a complete package I did have to hack around a bit to get it working successfully. I’ll write a more detailed explanation of the changes at some point. But here are the main points.\n  Buggy asynchronous FIFO implementation. Results in occasional buggy data in my testing. If sd_clk « wbclk then the original writers may not have seen this behavior. Currently I fix this by registering the next word of data. Ideally you would replace the FIFO implementation.\n  No example of how to wire into a system. It’s essential to output DATA and CMD signals at the negative edge, to ensure that setup/hold timing is satisfied on the SD cards Internal receivers. This is because data is latched on the rising edge. Registering on the neg-edge inside the I/O block is working for me.\n  No sw-driver. I’ve written my own. (work in progress) See my implementation into FatFs here. It is based of the FatFs example targeting a micro controller with real SD hardware (not SPI mode)\n  This full SD controller is a huge improvement of the SPI based design I was using on the old hardware. But there are still many small areas to tweak in order to boost performance.\nHyperRAM My hyperRAM implementation is based off BML’s great work! I’ve used his PLL example for the Xillinx 7-series. I had to slightly modify timings for working with the DDR modules inside the Lattice ECP5. I’ve also written a basic wrapper and changed the burst read method. This supports wishbone linear bursts assuming that the master issues a request the cycle after an ACK. This is the case for the wb_streamer components, but not achievable with picosoc.\n  I’ve hit a few issues with timing on the hyperRAM bus. For awhile it was working perfectly in hardware but the simulator was failing. If I adjusted the code to work on the simulator then the hardware would fail. I think I have tracked this down after drawing out a diagram of the signal timings.\nWhen reading data from the HyperRAM the signals operate in “Aligned” fashion. But there is a delay of up to 5.5ns in the output of this data from the previous clock edge. I was attempting to sample this signal with Sys_clk which edges should be 5.2ns BEFORE the HyperBus clock. This also explains why my simulation was failing.\nCMOS Capture Controller (ccc) This is a module that I have written. It consists of a set of wishbone registers, and logic that operates with the Camera Clock. The main function of this module is to support gating the data stream using v-sync to support capturing a complete frame. Due to it’s position in the design I have started to add new features into this module. including clocks_per_frame, pixels_per_frame, total_frames_seen.\npixels per frame enables the hardware to automatically determine which model of camera is connected a 320 or 640 model.\n Current ECP5 Logic usage With all the modules mentioned above I am just over the 12K LUT usage of the ECP5. This is about half of the total available resources. So I think I made a good choice using the ECP5-25F instead of the slightly cheaper ECP5-12F*\n  Update:\n*The ECP5 is actually contains 25k LUTs inside, there is no 12k die. When making use of the Yosys/NextPnR all 25k LUTs are available\n ","wordCount":"1034","inLanguage":"en","image":"https://gregdavill.github.io/images/IMG_5073.JPG","datePublished":"2018-11-03T00:00:00Z","dateModified":"2018-11-03T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://gregdavill.github.io/posts/boson-frame-grabber-pt5/"},"publisher":{"@type":"Organization","name":"Greg Davill's Projects","logo":{"@type":"ImageObject","url":"https://gregdavill.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add('dark'):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove('dark'):window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script><header class=header><nav class=nav><div class=logo><a href=https://gregdavill.github.io/ accesskey=h title="Greg Davill's Projects (Alt + H)">Greg Davill's Projects</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://gregdavill.github.io/archives title=Archive><span>Archive</span></a></li><li><a href=https://gregdavill.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://gregdavill.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://gregdavill.github.io/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://gregdavill.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://gregdavill.github.io/posts/>Posts</a></div><h1 class=post-title>Boson Frame Grabber Part 5</h1><div class=post-description>Details about the SoC architecture in the Boson Frame Grabber</div><div class=post-meta><span title="2018-11-03 00:00:00 +0000 UTC">November 3, 2018</span>&nbsp;·&nbsp;5 min</div></header><div class=post-content><h2 id=rtl-architecture>RTL Architecture<a hidden class=anchor aria-hidden=true href=#rtl-architecture>#</a></h2><p>The original version of the frame grabbing PCB used an iCE40 HX8K FPGA. This turned out to be a little small for the features I wanted to add. I managed to get it to a state where it would capture images from the Boson 320, but everything was hardwired together, and not easy to alter or reuse.</p><p>In order to improve module reuse and extendability a standard interface should be used. There are a few of these internal bus architectures available. I’ve decided to use wishbone, Mainly because I’ve been able to find existing wishbone modules that perform most of the major functionality of the frame grabber I’m building.</p><figure><a href=/posts/boson-frame-grabber-pt5/images/Arch_004.png><img srcset="/posts/boson-frame-grabber-pt5/images/Arch_004_hud36ab14ca3d9b24daa73139bf53e1cf4_31649_320x0_resize_box_2.png 320w,
/posts/boson-frame-grabber-pt5/images/Arch_004_hud36ab14ca3d9b24daa73139bf53e1cf4_31649_600x0_resize_box_2.png 600w,
/posts/boson-frame-grabber-pt5/images/Arch_004_hud36ab14ca3d9b24daa73139bf53e1cf4_31649_1200x0_resize_box_2.png 2x" src=/posts/boson-frame-grabber-pt5/images/Arch_004_hud36ab14ca3d9b24daa73139bf53e1cf4_31649_600x0_resize_box_2.png alt></a></figure><hr><h2 id=components>Components<a hidden class=anchor aria-hidden=true href=#components>#</a></h2><h3 id=wb_interconhttpsgithubcomolofkwb_intercon><a href=https://github.com/olofk/wb_intercon>wb_intercon</a><a hidden class=anchor aria-hidden=true href=#wb_interconhttpsgithubcomolofkwb_intercon>#</a></h3><p>Maybe the most important component. It is a collection of verilog components (mux, arbiter, upscaler, downscaler) and a python script that automatically generates all the required modules instantiations and wiring based on a simple easily human readable configuration file.</p><p>Documentation is a little bit lacking for this. I had to do a bit of reverse engineering on the python parser to understand the format required of the configuration file. For convenience of anyone else wanting to use this component here is a short description. There are two main configuration types, {master, slave} the master needs to know which slaves it will be connected to. The slaves need a base memory address and a length.</p><p>(Some care needs to be taken to ensure that memory segments do not overlap between slaves)</p><p>A python script takes this config file and creates two files a Verilog file and a Verilog header. This script pre-wires in muxes and arbiters as required if two masters have requested to have access over the same slave.</p><pre><code>[master cpu0]
slaves =
 ram0

[slave ram0]
offset=0x00000000
size=0x4000
</code></pre><h3 id=wb_streamerhttpsgithubcomolofkwb_streamer><a href=https://github.com/olofk/wb_streamer>wb_streamer</a><a hidden class=anchor aria-hidden=true href=#wb_streamerhttpsgithubcomolofkwb_streamer>#</a></h3><p>The streamer translates between a stream interface and wishbone transactions. It supports configurable burst length. The stream interface is extendable to support the data from the camera directly. Which is essentially a parallel stream. Combined with some glue logic and other stream utilities (stream_upsizer, stream_dc_fifo) this makes up the main logic to capture the camera data into RAM.</p><h3 id=picosochttpsgithubcomcliffordwolfpicorv32treemasterpicosoc><a href=https://github.com/cliffordwolf/picorv32/tree/master/picosoc>picoSoC</a><a hidden class=anchor aria-hidden=true href=#picosochttpsgithubcomcliffordwolfpicorv32treemasterpicosoc>#</a></h3><p>PicoSoC is a small wrapper around picorv32, a small and robust implementation of the RISCV open source CPU architecture. The wrapper includes a SPI driver to read instruction from a SPI FLASH (typically shared with config memory). A simple UART diver, and an optional wishbone / AXI wrapper. Since the rest of my system is using the wishbone wrapper I am using the wishbone wrapper. Note this CPU does not have the greatest IPC values, so it’s more targeted as a data-path controller for there higher performance logic in your system.</p><h3 id=sd-controller-sdchttpsgithubcommczerskisd-card-controller><a href=https://github.com/mczerski/SD-card-controller>SD controller (sdc)</a><a hidden class=anchor aria-hidden=true href=#sd-controller-sdchttpsgithubcommczerskisd-card-controller>#</a></h3><p>This is a complete 1/4bit open source SD controller. It includes a wishbone configuration interface, and a wishbone master to read/write data blocks. The inclusion of the wishbone master is essentially a dedicated DMA.</p><p>Although it’s a complete package I did have to hack around a bit to get it working successfully. I’ll write a more detailed explanation of the changes at some point. But here are the main points.</p><ul><li><p>Buggy asynchronous FIFO implementation. Results in occasional buggy data in my testing. If sd_clk &#171; wbclk then the original writers may not have seen this behavior. Currently I fix this by registering the next word of data. Ideally you would replace the FIFO implementation.</p></li><li><p>No example of how to wire into a system. It’s essential to output DATA and CMD signals at the negative edge, to ensure that setup/hold timing is satisfied on the SD cards Internal receivers. This is because data is latched on the rising edge. Registering on the neg-edge inside the I/O block is working for me.</p></li><li><p>No sw-driver. I’ve written my own. (work in progress) See my implementation into FatFs here. It is based of the FatFs example targeting a micro controller with real SD hardware (not SPI mode)</p></li></ul><p>This full SD controller is a huge improvement of the SPI based design I was using on the old hardware. But there are still many small areas to tweak in order to boost performance.</p><h3 id=hyperramhttpsgithubcomblackmesalabshyperram><a href=https://github.com/blackmesalabs/hyperram/>HyperRAM</a><a hidden class=anchor aria-hidden=true href=#hyperramhttpsgithubcomblackmesalabshyperram>#</a></h3><p>My hyperRAM implementation is based off BML’s great work! I’ve used his PLL example for the Xillinx 7-series. I had to slightly modify timings for working with the DDR modules inside the Lattice ECP5. I’ve also written a basic wrapper and changed the burst read method. This supports wishbone linear bursts assuming that the master issues a request the cycle after an ACK. This is the case for the wb_streamer components, but not achievable with picosoc.</p><figure><a href=/posts/boson-frame-grabber-pt5/images/IMG_5073.JPG><img srcset="/posts/boson-frame-grabber-pt5/images/IMG_5073_hu06ee28d82ed7421929a9230352ebe428_186206_320x0_resize_q75_box.JPG 320w,
/posts/boson-frame-grabber-pt5/images/IMG_5073_hu06ee28d82ed7421929a9230352ebe428_186206_600x0_resize_q75_box.JPG 600w,
/posts/boson-frame-grabber-pt5/images/IMG_5073_hu06ee28d82ed7421929a9230352ebe428_186206_1200x0_resize_q75_box.JPG 2x" src=/posts/boson-frame-grabber-pt5/images/IMG_5073_hu06ee28d82ed7421929a9230352ebe428_186206_600x0_resize_q75_box.JPG alt></a></figure><p>I’ve hit a few issues with timing on the hyperRAM bus. For awhile it was working perfectly in hardware but the simulator was failing. If I adjusted the code to work on the simulator then the hardware would fail. I think I have tracked this down after drawing out a diagram of the signal timings.</p><p>When reading data from the HyperRAM the signals operate in “Aligned” fashion. But there is a delay of up to 5.5ns in the output of this data from the previous clock edge. I was attempting to sample this signal with Sys_clk which edges should be 5.2ns BEFORE the HyperBus clock. This also explains why my simulation was failing.</p><h3 id=cmos-capture-controller-ccc><a href>CMOS Capture Controller (ccc)</a><a hidden class=anchor aria-hidden=true href=#cmos-capture-controller-ccc>#</a></h3><p>This is a module that I have written. It consists of a set of wishbone registers, and logic that operates with the Camera Clock. The main function of this module is to support gating the data stream using v-sync to support capturing a complete frame. Due to it’s position in the design I have started to add new features into this module. including clocks_per_frame, pixels_per_frame, total_frames_seen.</p><p>pixels per frame enables the hardware to automatically determine which model of camera is connected a 320 or 640 model.</p><hr><h2 id=current-ecp5-logic-usage>Current ECP5 Logic usage<a hidden class=anchor aria-hidden=true href=#current-ecp5-logic-usage>#</a></h2><p>With all the modules mentioned above I am just over the 12K LUT usage of the ECP5. This is about half of the total available resources. So I think I made a good choice using the ECP5-25F instead of the slightly cheaper ECP5-12F*</p><hr><blockquote><p>Update:</p><p>*The ECP5 is actually contains 25k LUTs inside, there is no 12k die. When making use of the Yosys/NextPnR all 25k LUTs are available</p></blockquote></div><footer class=post-footer><ul class=post-tags><li><a href=https://gregdavill.github.io/tags/boson/>boson</a></li><li><a href=https://gregdavill.github.io/tags/boson-frame-grabber/>boson-frame-grabber</a></li><li><a href=https://gregdavill.github.io/tags/thermal/>thermal</a></li></ul><nav class=paginav><a class=prev href=https://gregdavill.github.io/posts/boson-frame-grabber-pt6/><span class=title>« Prev Page</span><br><span>Boson Frame Grabber Part 6</span></a>
<a class=next href=https://gregdavill.github.io/posts/boson-frame-grabber-pt4/><span class=title>Next Page »</span><br><span>Boson Frame Grabber Part 4</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2021 <a href=https://gregdavill.github.io/>Greg Davill's Projects</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById('menu');menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script><script>document.querySelectorAll('pre > code').forEach(b=>{const c=b.parentNode.parentNode,a=document.createElement('button');a.classList.add('copy-code'),a.innerText='copy';function d(){a.innerText='copied!',setTimeout(()=>{a.innerText='copy'},2e3)}a.addEventListener('click',e=>{if('clipboard'in navigator){navigator.clipboard.writeText(b.textContent),d();return}const a=document.createRange();a.selectNodeContents(b);const c=window.getSelection();c.removeAllRanges(),c.addRange(a);try{document.execCommand('copy'),d()}catch(a){}c.removeRange(a)}),c.classList.contains("highlight")?c.appendChild(a):c.parentNode.firstChild==c||(b.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?b.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(a):b.parentNode.appendChild(a))})</script></body></html>