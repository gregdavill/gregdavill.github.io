<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Daikin ESP32 WiFi controller | Greg Davill's Projects</title>
<meta name=keywords content="ESP32,ESP32C3,esphome,homeassistant"><meta name=description content="An endeavour to add WiFi control to ducted air conditioner/heat pump system"><meta name=author content><link rel=canonical href=https://gregdavill.com/posts/daikin-esp-001/><link crossorigin=anonymous href=/assets/css/stylesheet.04f923ef139fd26f3f610e33d5547e96e9376d76dd088ad535ded906e3591395.css integrity="sha256-BPkj7xOf0m8/YQ4z1VR+luk3bXbdCIrVNd7ZBuNZE5U=" rel="preload stylesheet" as=style><link rel=icon href=https://gregdavill.com/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://gregdavill.com/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://gregdavill.com/favicon-32x32.png><link rel=apple-touch-icon href=https://gregdavill.com/apple-touch-icon.png><link rel=mask-icon href=https://gregdavill.com/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://gregdavill.com/posts/daikin-esp-001/><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><meta property="og:title" content="Daikin ESP32 WiFi controller"><meta property="og:description" content="An endeavour to add WiFi control to ducted air conditioner/heat pump system"><meta property="og:type" content="article"><meta property="og:url" content="https://gregdavill.com/posts/daikin-esp-001/"><meta property="og:image" content="https://gregdavill.com/posts/daikin-esp-001/images/015.jpg"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-10-13T00:00:00+00:00"><meta property="article:modified_time" content="2024-10-13T00:00:00+00:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://gregdavill.com/posts/daikin-esp-001/images/015.jpg"><meta name=twitter:title content="Daikin ESP32 WiFi controller"><meta name=twitter:description content="An endeavour to add WiFi control to ducted air conditioner/heat pump system"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://gregdavill.com/posts/"},{"@type":"ListItem","position":2,"name":"Daikin ESP32 WiFi controller","item":"https://gregdavill.com/posts/daikin-esp-001/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Daikin ESP32 WiFi controller","name":"Daikin ESP32 WiFi controller","description":"An endeavour to add WiFi control to ducted air conditioner/heat pump system","keywords":["ESP32","ESP32C3","esphome","homeassistant"],"articleBody":"Overview I’ve been adding various “smart” devices to my home to control with automation via home assistant. Initially this was just dimmable and hue adjustable lighting, and then WiFi enabled switches to connect up the physical switch plates around the house as inputs into home assistant. And now I also have solar and power monitoring connected up into home assistant too.\nI’ve wanted to add control and monitoring of my reverse cycle air conditioner into home assistant too. This would enable a skew of extra features that the default control panel and interface lack.\nEasily setting one-off timers Controlling the unit from the couch/bed Smart thermostat ranges where the unit only runs when solar is available Turning the unit off when I leave or enter The A/C unit in question is a ducted reverse cycle air conditioner from Daikin. It features a ceiling unit which serves as an air intake, this runs through a heat exchanger and is ducted out to various rooms. The ceiling unit uses refrigerant lines connected to an outdoor unit. To form a heat pump. The system works in both a cooling or heating mode.\nWhen adding devices to my smart home network I’m a bit particular. I try to ensure that devices are under local control not requiring an internet connection to perform their standard functions. I don’t want my lights to stop working because of an AWS outage. Or control of my air conditioner to stop because a manufacturer decides to turn off servers/services. This does limit my options, but is a strong driver for the choices in this project.\nAdding automation Off the shelf solutions to control split-systems do exist, however these typically rely on an IR control scheme. My unit does not have an IR controller, and instead uses a hardwired control panel on a wall that is connected into the ceiling unit. Daikin do provide a WiFi controller, It’s a little bit unclear if this does in-fact support my exact unit. This is a $200-300 device (without install fees) and from a bit of online research is only designed to be used with their phone App. Although there does appear to be a way to sync it with home assistant it rely on an internet connection.\nI became interested in the hard-wired connection between the ceiling unit and the wall controller. There are only 2 pins so it must carry power and modulated data on the single pair of wires. I pulled the controller off the wall, and using a multimeter I measured ~15V. I didn’t see any coupling to GND on each of the pins. So cautiously I hooked it upto my scope to take a peek at what might be going on, and saw something pretty cool! At regular interval there was an AC coupled alternating phase signal present.\nI noticed on the back of the wall controller the wires connecting upto the ceiling were labelled P1/P2. So I googled P1P2 and came across an awesome project P1P2Serial. The P1P2Serial project had done what I was trying to do, and also had very good and clear documentation about the physical layer and protocol layer of the bus. I would urge anyone who is interested to dig into the resources available there to learn more. For completeness to this blog post I’m just skimming over the basics.\nThe Daikin controller has a MM1192 on the PCB, the datasheet for this part mentions it’s a “HBS-Compatible Driver and Receiver”, where HBS is short for “Home Bus Specification”. Maxim Semiconductor, now ADI has a compatible transceiver the MAX22088. There have a some App notes which go into detail about the physical layer.\nStandard 9600bps UART framing with even parity For a LOW in the UART byte, a half-bitwidth pulse is created, this alternates in polarity This provides enough info to start to attempt decoding. I took the data captured on my scope and imported it into pulseview. I AC coupled, took an absolute value then added a threshold to the signal to create a digital value. Then making use of pulseviews decoders I added a UART decoder. Recall that each UART bit is actually split in half, so I configured the UART decoder slightly fast, 9800bps, to ensure that it sampled in that first 1/2 bit, and not the LOW from the previous bit.\nThe decode worked and the bytes parity checks were coming back good.\nThis is where the Daikin system stops making use of homebus specification and their defined protocol layer, and implements their own protocol. Circling back to P1P2Serial, they’ve documented the protocol layer\nEach packet is 4 bytes to 24 bytes in length and consists of the following:\nByte Description Values 0 direction 00h = request from main controller to peripheral\n40h = response from peripheral 1 peripheral address 00h = heat pump\nFxh = external controller 2 packet type 1Xh = packets in basic communication with heat pump\n3Xh = packets from/to auxiliary controller(s) 0xh, 2xh, 60h-BFh = various parameter/status communication and settings n payload data Packet type specific data, up to 20 bytes 3 + n CRC checksum Looking at the decoded scope trace from earlier:\ndir: 40h Response from peripheral adr: 00h Heat pump type: 10h Basic communications First PCB Following my project naming scheme I opened up project codename and after a few clicks got “Sapphire Captain” as a project name from this project. The goal was to make use of the MM1192 transceiver with an ESP32C3 to create a standalone bus powered PCB. I had just started playing around with ESPHome as a way to easily create home assistant compatible LED strip controllers. I knew it was possible to create custom C++ components in ESPHome. So my plan was to make use of the ESP32C3’s RMT peripheral to capture and transmit the physical layer. And then write a small driver to implement enough protocol layer to marshal commands/status between the Daikin and home assistant.\nUnfortunately, having not used homebus or the MM1192 before my implementation of extracting power off the bus did not work. Due to this the project lay dormant for a few more months.\nSecond PCB When I finally picked up the project again I decided to make use of the MAX22088, it is a more expensive part, however it details exactly how to design a bus powered device with reference schematics. So I designed up a small board to be powered off the P1P2 bus, provide the raw voltage output, and then an isolated Tx/Rx connection so I could comfortably leave this hooked up to my A/C while also connected to my laptop, and be confident nothing would fry.\nThis was actually the first time I made use of JLCs PCBA assembly service. I ordered 5 assembled PCBs with DHL ended up around US$110. Not bad for a one off prototype design, if I’d have to buy a stencil, excess components, I’d end up at a similar cost.\nWith the boards in hand I plugged them in and boom immediately started getting regular blinking lights on the RX LED I’d placed on the board! Hooking up my saleae logic analyser I could see reasonable looking signals coming from the board. Now I could dive into the firmware to work on interpreting the packets and responding.\nI had looked through the code on P1P2Serial, which was mostly for different models of Daikins, and tried to implement it in an ESP32-IDF based project. After I’d adjusted some AC coupling caps on my MAX22088 board to handle the 9600bps signaling. It seemed like the Daikin was seeing my messages. I could turn the unit ON/OFF with a physical button on the ESP32 board. But it would lock out the main control panel.\nAfter reading through the P1P2Serial code a bit more I noticed they detect a header of [00h, F0h, 30h] message as an Auxiliary controller status, and reply to it with an zero length payload acknowledgement [40h, F0h, 30h, 6Dh]. After issuing this, a few additional messages to us (F0h) started being sent! Nice.\nOnce some additional messages are acknowledged, message 38h is sent on each message cycle. Which is ~300ms or longer depending on number of messages in the current cycle. 38h is referred to as “FXMQ control” in P1P2, and appears as the primary mechanism an auxillary controller talks to the main controller.\nThe main controller sends the message to us, which contains the current status and control parameters. In our reply we are able to set new control values, (operating mode, target temperature, etc). Since Daikin doesn’t provide documentation for these low-level messages some bits are still unknown in function.\nMy ESPHome code fills out the payload like so:\nif (buffer[0] == 0x00 \u0026\u0026 buffer[1] == 0xF0) { const uint8_t *payload = \u0026buffer[3]; switch (buffer[2]) { case 0x38: { ESP_LOGI(TAG, \"FXMQ control message (0x38)\"); uint8_t ping_response[] = { 0x40, 0xF0, 0x38, // Header (uint8_t)(payload[0] \u0026 0x01), // target status payload[2], // target operating mode payload[4], // target temperature_cooling 0x00, payload[6], // target fan_speed 0x00, payload[8], // target temperature_heating 0x00, payload[10], // target heat_fan speed payload[11], // unknown 0x00, 0x00, 0x00, payload[15], // C0, E0 when payload[0] set to 1 0x00, 0x00, 0x00, 0xFF // crc byte, gets calculated later }; ... ESPHome I ported the RMT code over to ESPHome, this was a bit more trouble than expected since ESPHome makes use of IDF v4, I had used v5 for my initial code. Between versions the API for RMT has changed significantly. But with that change done in ESPHome I made use of the Climate component. This creates this interface in home assistant. There is a control function to implement, this enables home assistant to device control. When we have new sensor/status data to report, the climate class gives us sensors we can update and publish back to home assistant.\nUp to this point I had a 10m cable routed from the wall controller around a hallway and into my electronics lab bench. This worked well for debugging and development. But it had been kept in this state for a few months. 🫣 To quickly neaten up the install I 3d printed a small enclosure and wired up the MAX22088 breakout board into an ESP32C3 board I developed for LED lighting. ESPHome provides an easy way to configure an OTA bootloader, and WiFi logging. So even through the board was not one my desk anymore I was still able to continue debugging and fixing higher-level protocol bugs with the firmware.\nCustom ESP32 board Having had 5 of the MAX22088 transceiver boards built I didn’t want them to go to waste when I created the final hardware for this project. So I developed a single layer ESP32C3 board that could be mounted to the back of the MAX22088 boards. If I didn’t have this requirement these two circuits could easily have been routed onto the one PCB.\nThe circuit is just an ESP32C3, and a DCDC step down circuit to provide a 3v3 rail. and a single LED. I purposefully avoided a USB connector on this board opting for a slimmer design, my plan was to use the UART bootloader to load an initial firmware image, then exclusively use OTA. Hardware designers who make heavy use of the ESP might notice that I didn’t bring out GPIO9 to a test-point. This is a strapping pin and needed to enter USB/UART boot. -_-\nDue to the LGA style of the ESP32C3 module it’s not super easy to access the GPIO9 pin. Since I only needed to access it once, I tried to avoid reflowing and reworking in a proper test-point. Instead I used an alligator clip to ground my scalpel blade, and with some careful positioning and wiggling managed to wedge it under the ESP module and make contact with the GPIO pin.\nA custom designed 3d printed enclosure was designed to cover the entire module. I made use of Autodesk Fusion for the design, importing the PCB solid models and forming an enclosure around them. The enclosure is 2 pieces and fits together securely with M2.5 screws.\nThe finished enclosure turned out great printed in a MJF Nylon material offered by JLC.\nHomeKit integration Home assistant has a great integration to behave like an Apple HomeKit Hub, this enables control of the devices from Apple Home, which is tightly integrated into iOS and MacOS. This meant that after getting the A/C working with Home assistant it just also works with Apple Home. This worked very well for Heat/Cool/Auto modes of the unit, but there was no control over the Fan Only mode.\nThe Fan Only mode, circulates air throughout the house, but doesn’t active the heat pump. So it is very energy efficient. It was desirable to add control of this feature, after a little bit of research through ESPHome docs I found templates should help me achieve this goal. By defining a template fan, we can expose a fan controller to Apple, and when we receive control messages we can re-route them to control the A/C instead.\nThis is the configuration I added\nclimate: - platform: daikin_ducted id: daikin0 name: \"Ducted AC\" on_state: then: lambda: |- auto call = id(templatefan0).make_call(); call.set_state(x.mode == climate::CLIMATE_MODE_FAN_ONLY); if(x.fan_mode == climate::CLIMATE_FAN_LOW) call.set_speed(1); else if(x.fan_mode == climate::CLIMATE_FAN_MEDIUM) call.set_speed(2); else if(x.fan_mode == climate::CLIMATE_FAN_HIGH) call.set_speed(3); if( id(templatefan0).speed != call.get_speed() || id(templatefan0).state != call.get_state()) call.perform(); fan: - platform: template name: \"Ducted Fan\" id: templatefan0 speed_count: 3 on_state: then: lambda: |- auto call = id(daikin0).make_call(); call.set_mode(x-\u003estate ? \"FAN_ONLY\" : \"OFF\"); if(id(daikin0).mode != call.get_mode()) call.perform(); on_speed_set: then: lambda: |- auto call = id(daikin0).make_call(); switch(x) { case 1: call.set_fan_mode(\"LOW\"); break; case 2: call.set_fan_mode(\"MEDIUM\"); break; case 3: call.set_fan_mode(\"HIGH\"); break; default: break; } if(id(daikin0).fan_mode != call.get_fan_mode()) call.perform(); The lambdas contain C++ snippets which marshal across the FAN_ONLY control of the A/C to and from the template fan. Care is needed to check and only perform the call() action on new data. Otherwise a loop is formed where each devices on_state lambda calls the other on_state lambda.\nWith this extra yaml code in place, an extra fan device appears in the Apple Home app. It shows the status if the A/C in fan only mode, and enables control from iOS.\nIDF bugs The system has been working great for a few months on the custom hardware, hidden away in the wall. However when adding the new fan only features I noticed that the firmware was reporting a CRC error on a specific message, I added some extra debugging messages to get a bit more insight into the issue. Every 5 minutes the main controller sends a request for the heat-pumps name (message type A1h). When the heat pump responds the message the ESP tries to decode ends up corrupted.\n[10:16:19][VV][homebus:217][rmt_rx]: rx: (len=768, buffer=0x3fc99358) [10:16:19][VV][homebus:088][rmt_rx]: l=20 [00 00 a1 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 45] [10:16:19][VV][homebus:217][rmt_rx]: rx: (len=1016, buffer=0x3fc99098) [10:16:19][VV][homebus:088][rmt_rx]: l=30 [00 00 00 00 00 00 00 00 00 45 40 00 a1 00 52 5a 51 31 30 30 4c 56 31 00 00 00 00 00 00 58] [10:16:19][E][daikin_ducted.climate:062][rmt_rx]: Packet CRC error 58 != 3f (length = 30) [10:16:19][VV][esp-idf:000][rmt_rx]: I (300093) daikin_ducted.climate: 0x3fca4070 00 00 00 00 00 00 00 00 00 45 40 00 a1 00 52 5a |.........E@...RZ| [10:16:19][VV][esp-idf:000][rmt_rx]: I (300096) daikin_ducted.climate: 0x3fca4080 51 31 30 30 4c 56 31 00 00 00 00 00 00 58 00 00 |Q100LV1......X..| [10:16:19][VV][homebus:217][rmt_rx]: rx: (len=736, buffer=0x3fc99498) [10:16:19][VV][homebus:088][rmt_rx]: l=23 [00 f0 35 52 5a 51 31 30 30 4c 56 31 00 00 00 00 00 00 00 00 00 00 67] [10:16:19][I][daikin_ducted.climate:317][rmt_rx]: Outside Name(0x35): RZQ100LV1 The message is not directed at us, so it’s not actually essential that we decode it, but I still wanted to work out the issue, and fix it. Incase it caused issues with other messages that we do need to handle. To provide a bit more info for debugging I took the controller out of the wall and hooked up the saleae again, and took a capture alongside the log recorded by the ESP.\nThis capture confirmed the messages were transmitted correctly over the bus, so the issue is on the ESP side.\nActual messages on bus: [00 00 a1 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 45] [40 00 a1 00 52 5a 51 31 30 30 4c 56 31 00 00 00 00 00 00 58] The RMT peripheral in the ESP is what I’m using to capture the bus. It combines a counter and edge detection to store timestamps of high/low transitions. This takes a large ISR overhead off the processor, by configuring a timeout value you can receive an interrupt while mid-packet if the buffers fill, or at the end of a packet. Here is a diagram from the ESP32C3 reference manual describing the peripheral.\nNote that the RAM for the peripheral is dedicated and listed as 192 * 32bit. This is split into 4 blocks each 48 * 32bits in size. Each 32bit word stores 2 transitions/periods. So in a single block of RMT RAM we can save 96 edges of data, before an interrupt routine needs to take over and empty that data. The ESP-IDF driver for RMT takes care of this step for us. The transitions are stored in a system memory buffer that is passed to our application only once a timeout event happens.\nThis took me a few hours to figure out, but keen eyed readers might have started to piece together the issue. In my extra debugging info listed above I record the length and buffer address of the raw RMT data before processing. The first buffer is 768 bytes in length. This is 384 edges; 192 falling, and 192 rising. This means the packet is an exact multiple of the RMT RAM blocks. Two more pieces of the puzzle:\nOn a timeout, the RMT peripheral inserts an entry with a period of 0 to indicate the end of an RMT packet into it’s RAM. In ESP-IDF v4.4.8, the RMT driver interrupt processes the timeout flag before the buffer threshold flag. Have you worked out the bug with these clues?\nIn my case I’ve configured the RX2 channel to make use of 2 RAM blocks, the driver configures the RMT_CH2_RX_LIM_REG to 48 (one RAM block) in this case. Consider what happens if a RMT RAM block is filled with data, but hasn’t rolled over the RMT_CH2_RX_LIM_REG yet, so a RXT_CH2_RX_THR_EVENT_INT hasn’t occurred, but will occur if another edge is seen. We’re at the end of a packet, so not more edge will be seen. The hardware detects a timeout, so inserts a 0 period into the buffer. This simultaneously produces a RXT_CH2_RX_THR_EVENT_INT and RMT_CH2_RX_END_INT.\n1. The drivers interrupt handler runs and sees the `RMT_CH2_RX_END_INT` status so it handles that and passes data to our application, which results in this buffer. [00 00 a1 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 45] 2. It continues through the interrupt routine and starts processing the `RXT_CH2_RX_THR_EVENT_INT` interrupt. 48 words of RMT data is stored in the driver SRAM buffer [00 00 00 00 00 00 00 00 00 45 ... 3. The next packet arrives and is appended to the erroneous data left over by the bug. ... 40 00 a1 00 52 5a 51 31 30 30 4c 56 31 00 00 00 00 00 00 58] I’m currently stuck on IDF v4, as this is what ESPHome is still using, and per Espressif’s support terms they ceased bugfix releases in July 2024 with the release of v4.4.8. An easy fix for this is to clear the RXT_CH2_RX_THR_EVENT_INT status if we handle a RMT_CH2_RX_END_INT even in the same interrupt routine. However since bugfixes in the SDK won’t be accepted now, I’ve implemented a fix that works in my use case at the application level.\nrmt_item32_t *items = (rmt_item32_t *)xRingbufferReceive(rb, \u0026length, portMAX_DELAY); // ESP-IDF bug, if rx_end completes on a rx_lim boundary, writing of an rx_end marker // triggers the rx_thresh interrupt and affixes the end of this packet to the start of the next. // Can't be fixed in IDF as 4.4.8 isn't getting any additional bug fixes. // As configured this boundary is 384 bytes. Re-starting the rmt_rx resets the buffer pointers. if((length % 384) == 0){ esp_err_t error = rmt_rx_start(RMT_CHANNEL_2, true); if (error != ESP_OK) { ESP_LOGE(TAG, \"Restart of rmt_rx failed\"); } } if (items) { // process RMT data } This is a pretty clean fix. This does create a period where packets may not be detected, but the Daikin protocol leaves 10-20ms between packets so this isn’t an issue in this case. And we now correctly receive packets that are a multiple of RMT RAM size!\n[09:56:17][VV][homebus:217][rmt_rx]: rx: (len=768, buffer=0x3fc99348) [09:56:17][VV][homebus:088][rmt_rx]: l=20 [00 00 a1 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 45] [09:56:17][VV][homebus:217][rmt_rx]: rx: (len=632, buffer=0x3fc99098) [09:56:17][VV][homebus:088][rmt_rx]: l=20 [40 00 a1 00 52 5a 51 31 30 30 4c 56 31 00 00 00 00 00 00 58] [09:56:17][VV][homebus:217][rmt_rx]: rx: (len=736, buffer=0x3fc99318) [09:56:17][VV][homebus:088][rmt_rx]: l=23 [00 f0 35 52 5a 51 31 30 30 4c 56 31 00 00 00 00 00 00 00 00 00 00 67] [09:56:17][I][daikin_ducted.climate:317][rmt_rx]: Outside Name(0x35): RZQ100LV1 Conclusion Thanks for reading along with this journey. If you’re after an assembled device to control your A/C check out the hardware currently sold at the P1P2MQTT project, when I started the hardware wasn’t quite doing what I wanted, but it’s come a long way and would have just worked for my A/C.\nDownloads If you want to download the circuit designs or ESPHome firmware that I’ve created it’s open source licensed and available. I’d love to hear if you’re able to add some smarts to your ducted air conditioners. I’m not planning on selling assembled units of this design.\nMAX22088 breakout “hb-bob” design: KiCad source Gebrers/Schematic ESP32C3 addon esp-daikin design: KiCad source Gebrers/Schematic ESPHome yaml/Custom C++ component https://github.com/gregdavill/daikin-esp/tree/main/esphome ","wordCount":"3674","inLanguage":"en","image":"https://gregdavill.com/posts/daikin-esp-001/images/015.jpg","datePublished":"2024-10-13T00:00:00Z","dateModified":"2024-10-13T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://gregdavill.com/posts/daikin-esp-001/"},"publisher":{"@type":"Organization","name":"Greg Davill's Projects","logo":{"@type":"ImageObject","url":"https://gregdavill.com/favicon.ico"}}}</script></head><body class=dark id=top><script>localStorage.getItem("pref-theme")==="light"&&document.body.classList.remove("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://gregdavill.com/ accesskey=h title="Greg Davill's Projects (Alt + H)">Greg Davill's Projects</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://gregdavill.com/archives title=Archive><span>Archive</span></a></li><li><a href=https://gregdavill.com/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://gregdavill.com/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://gregdavill.com/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://gregdavill.com/>Home</a>&nbsp;»&nbsp;<a href=https://gregdavill.com/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">Daikin ESP32 WiFi controller</h1><div class=post-description>An endeavour to add WiFi control to ducted air conditioner/heat pump system</div><div class=post-meta><span title='2024-10-13 00:00:00 +0000 UTC'>October 13, 2024</span>&nbsp;·&nbsp;18 min&nbsp;|&nbsp;<a href=https://github.com/gregdavill/gregdavill.github.io/blob/main/blog-src/content/posts/daikin-esp-001/index.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><figure class=entry-cover><img loading=eager srcset="https://gregdavill.com/posts/daikin-esp-001/images/015_hu13710095006452651509.jpg 360w ,https://gregdavill.com/posts/daikin-esp-001/images/015_hu2969260134147687303.jpg 480w ,https://gregdavill.com/posts/daikin-esp-001/images/015_hu5337073785348771519.jpg 720w ,https://gregdavill.com/posts/daikin-esp-001/images/015_hu5908415240210026021.jpg 1080w ,https://gregdavill.com/posts/daikin-esp-001/images/015_hu4855285979271748124.jpg 1500w ,https://gregdavill.com/posts/daikin-esp-001/images/015.jpg 2736w" sizes="(min-width: 768px) 720px, 100vw" src=https://gregdavill.com/posts/daikin-esp-001/images/015.jpg alt width=2736 height=1824></figure><div class=post-content><h1 id=overview>Overview<a hidden class=anchor aria-hidden=true href=#overview>#</a></h1><p>I&rsquo;ve been adding various &ldquo;smart&rdquo; devices to my home to control with automation via home assistant. Initially this was just dimmable and hue adjustable lighting, and then WiFi enabled switches to connect up the physical switch plates around the house as inputs into home assistant. And now I also have solar and power monitoring connected up into home assistant too.</p><p>I&rsquo;ve wanted to add control and monitoring of my reverse cycle air conditioner into home assistant too. This would enable a skew of extra features that the default control panel and interface lack.</p><ul><li>Easily setting one-off timers</li><li>Controlling the unit from the couch/bed</li><li>Smart thermostat ranges where the unit only runs when solar is available</li><li>Turning the unit off when I leave or enter</li></ul><p>The A/C unit in question is a ducted reverse cycle air conditioner from Daikin. It features a ceiling unit which serves as an air intake, this runs through a heat exchanger and is ducted out to various rooms. The ceiling unit uses refrigerant lines connected to an outdoor unit. To form a heat pump. The system works in both a cooling or heating mode.</p><p>When adding devices to my smart home network I&rsquo;m a bit particular. I try to ensure that devices are under local control not requiring an internet connection to perform their standard functions. I don&rsquo;t want my lights to stop working because of an AWS outage. Or control of my air conditioner to stop because a manufacturer decides to turn off servers/services. This does limit my options, but is a strong driver for the choices in this project.</p><h1 id=adding-automation>Adding automation<a hidden class=anchor aria-hidden=true href=#adding-automation>#</a></h1><p>Off the shelf solutions to control split-systems do exist, however these typically rely on an IR control scheme. My unit does not have an IR controller, and instead uses a hardwired control panel on a wall that is connected into the ceiling unit. Daikin do provide a WiFi controller, It&rsquo;s a little bit unclear if this does in-fact support my exact unit. This is a $200-300 device (without install fees) and from a bit of online research is only designed to be used with their phone App. Although there does appear to be a way to sync it with home assistant it rely on an internet connection.</p><figure><img srcset="/posts/daikin-esp-001/images/001_hu17841725968959409776.jpg 390w,
/posts/daikin-esp-001/images/001_hu16606173407120289966.jpg 800w,
/posts/daikin-esp-001/images/001_hu6243270606718024246.jpg 2160w" src=/posts/daikin-esp-001/images/001_hu16606173407120289966.jpg alt></figure><p>I became interested in the hard-wired connection between the ceiling unit and the wall controller. There are only 2 pins so it must carry power and modulated data on the single pair of wires. I pulled the controller off the wall, and using a multimeter I measured ~15V. I didn&rsquo;t see any coupling to GND on each of the pins. So cautiously I hooked it upto my scope to take a peek at what might be going on, and saw something pretty cool! At regular interval there was an AC coupled alternating phase signal present.</p><figure><img srcset="/posts/daikin-esp-001/images/002_hu12013886785211886189.jpg 390w,
/posts/daikin-esp-001/images/002_hu13136230937707173747.jpg 800w,
/posts/daikin-esp-001/images/002_hu7161526306239723896.jpg 2160w" src=/posts/daikin-esp-001/images/002_hu13136230937707173747.jpg alt></figure><p>I noticed on the back of the wall controller the wires connecting upto the ceiling were labelled P1/P2. So I googled P1P2 and came across an awesome project <a href=https://github.com/Arnold-n/P1P2MQTT>P1P2Serial</a>. The P1P2Serial project had done what I was trying to do, and also had very good and clear documentation about the physical layer and protocol layer of the bus. I would urge anyone who is interested to dig into the resources available there to learn more. For completeness to this blog post I&rsquo;m just skimming over the basics.</p><p>The Daikin controller has a MM1192 on the PCB, the datasheet for this part mentions it&rsquo;s a &ldquo;HBS-Compatible Driver and Receiver&rdquo;, where HBS is short for &ldquo;Home Bus Specification&rdquo;. Maxim Semiconductor, now ADI has a compatible transceiver the <a href=https://www.analog.com/en/products/max22088.html>MAX22088</a>. There have a some App notes which go into detail about the physical layer.</p><ul><li>Standard 9600bps UART framing with even parity</li><li>For a LOW in the UART byte, a half-bitwidth pulse is created, this alternates in polarity</li></ul><figure><img srcset="/posts/daikin-esp-001/images/003_hu15858983456222910685.png 390w,
/posts/daikin-esp-001/images/003_hu3072329808859058321.png 800w,
/posts/daikin-esp-001/images/003_hu16423007682441291256.png 2160w" src=/posts/daikin-esp-001/images/003_hu3072329808859058321.png alt></figure><p>This provides enough info to start to attempt decoding. I took the data captured on my scope and imported it into pulseview. I AC coupled, took an absolute value then added a threshold to the signal to create a digital value. Then making use of pulseviews decoders I added a UART decoder. Recall that each UART bit is actually split in half, so I configured the UART decoder slightly fast, 9800bps, to ensure that it sampled in that first 1/2 bit, and not the LOW from the previous bit.</p><p>The decode worked and the bytes parity checks were coming back good.</p><figure><img srcset="/posts/daikin-esp-001/images/004_hu5669682966465611950.png 390w,
/posts/daikin-esp-001/images/004_hu16929543596411598612.png 800w,
/posts/daikin-esp-001/images/004_hu8308744158628209928.png 2160w" src=/posts/daikin-esp-001/images/004_hu16929543596411598612.png alt></figure><p>This is where the Daikin system stops making use of homebus specification and their defined protocol layer, and implements their own protocol. Circling back to P1P2Serial, they&rsquo;ve documented the <a href=https://raw.githubusercontent.com/Arnold-n/P1P2MQTT/refs/heads/main/doc/LogicalFormat/README.md>protocol layer</a></p><p>Each packet is 4 bytes to 24 bytes in length and consists of the following:</p><table><thead><tr><th style=text-align:left>Byte</th><th style=text-align:left>Description</th><th style=text-align:left>Values</th></tr></thead><tbody><tr><td style=text-align:left>0</td><td style=text-align:left>direction</td><td style=text-align:left>00h = request from main controller to peripheral<br>40h = response from peripheral</td></tr><tr><td style=text-align:left>1</td><td style=text-align:left>peripheral address</td><td style=text-align:left>00h = heat pump<br>Fxh = external controller</td></tr><tr><td style=text-align:left>2</td><td style=text-align:left>packet type</td><td style=text-align:left>1Xh = packets in basic communication with heat pump<br>3Xh = packets from/to auxiliary controller(s)<br>0xh, 2xh, 60h-BFh = various parameter/status communication and settings</td></tr><tr><td style=text-align:left>n</td><td style=text-align:left>payload data</td><td style=text-align:left>Packet type specific data, up to 20 bytes</td></tr><tr><td style=text-align:left>3 + n</td><td style=text-align:left>CRC checksum</td><td style=text-align:left></td></tr></tbody></table><p>Looking at the decoded scope trace from earlier:</p><ul><li>dir: 40h Response from peripheral</li><li>adr: 00h Heat pump</li><li>type: 10h Basic communications</li></ul><h1 id=first-pcb>First PCB<a hidden class=anchor aria-hidden=true href=#first-pcb>#</a></h1><p>Following my project naming scheme I opened up <a href=http://projectcodename.com/>project codename</a> and after a few clicks got &ldquo;Sapphire Captain&rdquo; as a project name from this project. The goal was to make use of the MM1192 transceiver with an ESP32C3 to create a standalone bus powered PCB. I had just started playing around with <a href=https://esphome.io/>ESPHome</a> as a way to easily create home assistant compatible LED strip controllers. I knew it was possible to create custom C++ components in ESPHome. So my plan was to make use of the ESP32C3&rsquo;s RMT peripheral to capture and transmit the physical layer. And then write a small driver to implement enough protocol layer to marshal commands/status between the Daikin and home assistant.</p><figure><img srcset="/posts/daikin-esp-001/images/005_hu9922713320876586904.jpg 390w,
/posts/daikin-esp-001/images/005_hu5188660154394620840.jpg 800w,
/posts/daikin-esp-001/images/005_hu17784976644109278466.jpg 2160w" src=/posts/daikin-esp-001/images/005_hu5188660154394620840.jpg alt></figure><p>Unfortunately, having not used homebus or the MM1192 before my implementation of extracting power off the bus did not work. Due to this the project lay dormant for a few more months.</p><h1 id=second-pcb>Second PCB<a hidden class=anchor aria-hidden=true href=#second-pcb>#</a></h1><p>When I finally picked up the project again I decided to make use of the MAX22088, it is a more expensive part, however it details exactly how to design a bus powered device with reference schematics. So I designed up a small board to be powered off the P1P2 bus, provide the raw voltage output, and then an isolated Tx/Rx connection so I could comfortably leave this hooked up to my A/C while also connected to my laptop, and be confident nothing would fry.</p><p><figure><img srcset="/posts/daikin-esp-001/images/023_hu12258553988105608783.png 390w,
/posts/daikin-esp-001/images/023_hu14735006708011354675.png 800w,
/posts/daikin-esp-001/images/023_hu17016331827035824009.png 2160w" src=/posts/daikin-esp-001/images/023_hu14735006708011354675.png alt></figure><figure><img srcset="/posts/daikin-esp-001/images/006_hu17037813806153217202.jpg 390w,
/posts/daikin-esp-001/images/006_hu14709305952913251324.jpg 800w,
/posts/daikin-esp-001/images/006_hu2418053358427021889.jpg 2160w" src=/posts/daikin-esp-001/images/006_hu14709305952913251324.jpg alt></figure></p><p>This was actually the first time I made use of JLCs PCBA assembly service. I ordered 5 assembled PCBs with DHL ended up around US$110. Not bad for a one off prototype design, if I&rsquo;d have to buy a stencil, excess components, I&rsquo;d end up at a similar cost.</p><figure><img srcset="/posts/daikin-esp-001/images/007_hu1210080051137570499.jpg 390w,
/posts/daikin-esp-001/images/007_hu7150153121351631594.jpg 800w,
/posts/daikin-esp-001/images/007_hu17959116974982493747.jpg 2160w" src=/posts/daikin-esp-001/images/007_hu7150153121351631594.jpg alt></figure><p>With the boards in hand I plugged them in and boom immediately started getting regular blinking lights on the RX LED I&rsquo;d placed on the board! Hooking up my saleae logic analyser I could see reasonable looking signals coming from the board. Now I could dive into the firmware to work on interpreting the packets and responding.</p><p>I had looked through the code on P1P2Serial, which was mostly for different models of Daikins, and tried to implement it in an ESP32-IDF based project. After I&rsquo;d adjusted some AC coupling caps on my MAX22088 board to handle the 9600bps signaling. It seemed like the Daikin was seeing my messages. I could turn the unit ON/OFF with a physical button on the ESP32 board. But it would lock out the main control panel.</p><figure><img srcset="/posts/daikin-esp-001/images/008_hu16658415470892011802.jpg 390w,
/posts/daikin-esp-001/images/008_hu9042991252973016125.jpg 800w,
/posts/daikin-esp-001/images/008_hu234263607558261841.jpg 2160w" src=/posts/daikin-esp-001/images/008_hu9042991252973016125.jpg alt></figure><p>After reading through the P1P2Serial code a bit more I noticed they detect a header of [00h, F0h, 30h] message as an Auxiliary controller status, and reply to it with an zero length payload acknowledgement [40h, F0h, 30h, 6Dh]. After issuing this, a few additional messages to us (F0h) started being sent! Nice.</p><figure><img srcset="/posts/daikin-esp-001/images/009_hu10943569605395830523.png 390w,
/posts/daikin-esp-001/images/009_hu9000837754798819180.png 800w,
/posts/daikin-esp-001/images/009_hu13458342180267499326.png 2160w" src=/posts/daikin-esp-001/images/009_hu9000837754798819180.png alt></figure><p>Once some additional messages are acknowledged, message 38h is sent on each message cycle. Which is ~300ms or longer depending on number of messages in the current cycle. 38h is referred to as &ldquo;FXMQ control&rdquo; in P1P2, and appears as the primary mechanism an auxillary controller talks to the main controller.</p><p>The main controller sends the message to us, which contains the current status and control parameters. In our reply we are able to set new control values, (operating mode, target temperature, etc). Since Daikin doesn&rsquo;t provide documentation for these low-level messages some bits are still unknown in function.</p><p>My ESPHome code fills out the payload like so:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>if</span> (buffer[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>==</span> <span style=color:#ae81ff>0x00</span> <span style=color:#f92672>&amp;&amp;</span> buffer[<span style=color:#ae81ff>1</span>] <span style=color:#f92672>==</span> <span style=color:#ae81ff>0xF0</span>)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>uint8_t</span> <span style=color:#f92672>*</span>payload <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span>buffer[<span style=color:#ae81ff>3</span>];
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>switch</span> (buffer[<span style=color:#ae81ff>2</span>]) {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>case</span> <span style=color:#ae81ff>0x38</span><span style=color:#f92672>:</span> {
</span></span><span style=display:flex><span>          <span style=color:#a6e22e>ESP_LOGI</span>(TAG, <span style=color:#e6db74>&#34;FXMQ control message (0x38)&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>          <span style=color:#66d9ef>uint8_t</span> ping_response[] <span style=color:#f92672>=</span> {
</span></span><span style=display:flex><span>              <span style=color:#ae81ff>0x40</span>, <span style=color:#ae81ff>0xF0</span>, <span style=color:#ae81ff>0x38</span>,             <span style=color:#75715e>// Header
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>              (<span style=color:#66d9ef>uint8_t</span>)(payload[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>&amp;</span> <span style=color:#ae81ff>0x01</span>), <span style=color:#75715e>// target status
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>              payload[<span style=color:#ae81ff>2</span>],                   <span style=color:#75715e>// target operating mode
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>              payload[<span style=color:#ae81ff>4</span>],                   <span style=color:#75715e>// target temperature_cooling
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>              <span style=color:#ae81ff>0x00</span>,
</span></span><span style=display:flex><span>              payload[<span style=color:#ae81ff>6</span>],                   <span style=color:#75715e>// target fan_speed
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>              <span style=color:#ae81ff>0x00</span>,
</span></span><span style=display:flex><span>              payload[<span style=color:#ae81ff>8</span>],                   <span style=color:#75715e>// target temperature_heating
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>              <span style=color:#ae81ff>0x00</span>,
</span></span><span style=display:flex><span>              payload[<span style=color:#ae81ff>10</span>],                  <span style=color:#75715e>// target heat_fan speed
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>              payload[<span style=color:#ae81ff>11</span>],                  <span style=color:#75715e>// unknown
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>              <span style=color:#ae81ff>0x00</span>,
</span></span><span style=display:flex><span>              <span style=color:#ae81ff>0x00</span>,
</span></span><span style=display:flex><span>              <span style=color:#ae81ff>0x00</span>,
</span></span><span style=display:flex><span>              payload[<span style=color:#ae81ff>15</span>],                  <span style=color:#75715e>// C0, E0 when payload[0] set to 1
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>              <span style=color:#ae81ff>0x00</span>,
</span></span><span style=display:flex><span>              <span style=color:#ae81ff>0x00</span>,
</span></span><span style=display:flex><span>              <span style=color:#ae81ff>0x00</span>,
</span></span><span style=display:flex><span>              <span style=color:#ae81ff>0xFF</span>                          <span style=color:#75715e>// crc byte, gets calculated later
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>          };
</span></span><span style=display:flex><span>          ...
</span></span></code></pre></div><h1 id=esphome>ESPHome<a hidden class=anchor aria-hidden=true href=#esphome>#</a></h1><p>I ported the RMT code over to ESPHome, this was a bit more trouble than expected since ESPHome makes use of IDF v4, I had used v5 for my initial code. Between versions the API for RMT has changed significantly. But with that change done in ESPHome I made use of the Climate component. This creates this interface in home assistant. There is a control function to implement, this enables home assistant to device control. When we have new sensor/status data to report, the climate class gives us sensors we can update and publish back to home assistant.</p><figure><img srcset="/posts/daikin-esp-001/images/012_hu4570753671893936750.png 390w,
/posts/daikin-esp-001/images/012_hu14147939595010222035.png 800w,
/posts/daikin-esp-001/images/012_hu12148090111527800040.png 2160w" src=/posts/daikin-esp-001/images/012_hu14147939595010222035.png alt></figure><p>Up to this point I had a 10m cable routed from the wall controller around a hallway and into my electronics lab bench. This worked well for debugging and development. But it had been kept in this state for a few months. 🫣
To quickly neaten up the install I 3d printed a small enclosure and wired up the MAX22088 breakout board into an ESP32C3 board I developed for LED lighting. ESPHome provides an easy way to configure an OTA bootloader, and WiFi logging. So even through the board was not one my desk anymore I was still able to continue debugging and fixing higher-level protocol bugs with the firmware.</p><p><figure><img srcset="/posts/daikin-esp-001/images/010_hu1481545675495650135.jpg 390w,
/posts/daikin-esp-001/images/010_hu1927281801806869131.jpg 800w,
/posts/daikin-esp-001/images/010_hu17765021741386676458.jpg 2160w" src=/posts/daikin-esp-001/images/010_hu1927281801806869131.jpg alt></figure><figure><img srcset="/posts/daikin-esp-001/images/011_hu488092310662007634.jpg 390w,
/posts/daikin-esp-001/images/011_hu5015101967349976339.jpg 800w,
/posts/daikin-esp-001/images/011_hu12604009943845428787.jpg 2160w" src=/posts/daikin-esp-001/images/011_hu5015101967349976339.jpg alt></figure><figure><img srcset="/posts/daikin-esp-001/images/012_hu10596110620252097271.jpg 390w,
/posts/daikin-esp-001/images/012_hu14111616598631529189.jpg 800w,
/posts/daikin-esp-001/images/012_hu422140989352871744.jpg 2160w" src=/posts/daikin-esp-001/images/012_hu14111616598631529189.jpg alt></figure></p><h1 id=custom-esp32-board>Custom ESP32 board<a hidden class=anchor aria-hidden=true href=#custom-esp32-board>#</a></h1><p>Having had 5 of the MAX22088 transceiver boards built I didn&rsquo;t want them to go to waste when I created the final hardware for this project. So I developed a single layer ESP32C3 board that could be mounted to the back of the MAX22088 boards. If I didn&rsquo;t have this requirement these two circuits could easily have been routed onto the one PCB.</p><p><figure><img srcset="/posts/daikin-esp-001/images/013_hu12945864624884286327.jpg 390w,
/posts/daikin-esp-001/images/013_hu4428054360621126975.jpg 800w,
/posts/daikin-esp-001/images/013_hu14584339249053470473.jpg 2160w" src=/posts/daikin-esp-001/images/013_hu4428054360621126975.jpg alt></figure><figure><img srcset="/posts/daikin-esp-001/images/014_hu4854954015434177444.jpg 390w,
/posts/daikin-esp-001/images/014_hu6261740404288834236.jpg 800w,
/posts/daikin-esp-001/images/014_hu7362780050904285855.jpg 2160w" src=/posts/daikin-esp-001/images/014_hu6261740404288834236.jpg alt></figure></p><p>The circuit is just an ESP32C3, and a DCDC step down circuit to provide a 3v3 rail. and a single LED. I purposefully avoided a USB connector on this board opting for a slimmer design, my plan was to use the UART bootloader to load an initial firmware image, then exclusively use OTA. Hardware designers who make heavy use of the ESP might notice that I didn&rsquo;t bring out GPIO9 to a test-point. This is a strapping pin and needed to enter USB/UART boot. -_-</p><figure><img srcset="/posts/daikin-esp-001/images/024_hu9787302662014993966.png 390w,
/posts/daikin-esp-001/images/024_hu4704253864884949505.png 800w,
/posts/daikin-esp-001/images/024_hu468133730405060590.png 2160w" src=/posts/daikin-esp-001/images/024_hu4704253864884949505.png alt></figure><p>Due to the LGA style of the ESP32C3 module it&rsquo;s not super easy to access the GPIO9 pin. Since I only needed to access it once, I tried to avoid reflowing and reworking in a proper test-point. Instead I used an alligator clip to ground my scalpel blade, and with some careful positioning and wiggling managed to wedge it under the ESP module and make contact with the GPIO pin.</p><p><figure><img srcset="/posts/daikin-esp-001/images/015_hu1198653199898665405.jpg 390w,
/posts/daikin-esp-001/images/015_hu16407767648857529865.jpg 800w,
/posts/daikin-esp-001/images/015_hu2237460789114001469.jpg 2160w" src=/posts/daikin-esp-001/images/015_hu16407767648857529865.jpg alt></figure><figure><img srcset="/posts/daikin-esp-001/images/016_hu17413697540853121295.jpg 390w,
/posts/daikin-esp-001/images/016_hu5977343156008366525.jpg 800w,
/posts/daikin-esp-001/images/016_hu7292783034461276199.jpg 2160w" src=/posts/daikin-esp-001/images/016_hu5977343156008366525.jpg alt></figure><figure><img srcset="/posts/daikin-esp-001/images/017_hu16549027869790520819.jpg 390w,
/posts/daikin-esp-001/images/017_hu13636203876501188642.jpg 800w,
/posts/daikin-esp-001/images/017_hu12744036890523271275.jpg 2160w" src=/posts/daikin-esp-001/images/017_hu13636203876501188642.jpg alt></figure></p><p>A custom designed 3d printed enclosure was designed to cover the entire module. I made use of Autodesk Fusion for the design, importing the PCB solid models and forming an enclosure around them. The enclosure is 2 pieces and fits together securely with M2.5 screws.</p><figure><img srcset="/posts/daikin-esp-001/images/018_hu14520843206708265370.jpg 390w,
/posts/daikin-esp-001/images/018_hu13024258782508454729.jpg 800w,
/posts/daikin-esp-001/images/018_hu16912121049665616000.jpg 2160w" src=/posts/daikin-esp-001/images/018_hu13024258782508454729.jpg alt></figure><p>The finished enclosure turned out great printed in a MJF Nylon material offered by JLC.</p><p><figure><img srcset="/posts/daikin-esp-001/images/019_hu1321153840844197212.jpg 390w,
/posts/daikin-esp-001/images/019_hu18401919993432729020.jpg 800w,
/posts/daikin-esp-001/images/019_hu10194458548764962752.jpg 2160w" src=/posts/daikin-esp-001/images/019_hu18401919993432729020.jpg alt></figure><figure><img srcset="/posts/daikin-esp-001/images/020_hu7536654918789899663.jpg 390w,
/posts/daikin-esp-001/images/020_hu11047748614553032736.jpg 800w,
/posts/daikin-esp-001/images/020_hu771819793487984562.jpg 2160w" src=/posts/daikin-esp-001/images/020_hu11047748614553032736.jpg alt></figure><figure><img srcset="/posts/daikin-esp-001/images/021_hu16374998397195723891.jpg 390w,
/posts/daikin-esp-001/images/021_hu12687315897478173334.jpg 800w,
/posts/daikin-esp-001/images/021_hu2856304285997493062.jpg 2160w" src=/posts/daikin-esp-001/images/021_hu12687315897478173334.jpg alt></figure><figure><img srcset="/posts/daikin-esp-001/images/022_hu11561332628218977162.jpg 390w,
/posts/daikin-esp-001/images/022_hu15192696828465555102.jpg 800w,
/posts/daikin-esp-001/images/022_hu807628148116720956.jpg 2160w" src=/posts/daikin-esp-001/images/022_hu15192696828465555102.jpg alt></figure></p><h1 id=homekit-integration>HomeKit integration<a hidden class=anchor aria-hidden=true href=#homekit-integration>#</a></h1><p>Home assistant has a great integration to behave like an Apple HomeKit Hub, this enables control of the devices from Apple Home, which is tightly integrated into iOS and MacOS. This meant that after getting the A/C working with Home assistant it just also works with Apple Home. This worked very well for Heat/Cool/Auto modes of the unit, but there was no control over the Fan Only mode.</p><p>The Fan Only mode, circulates air throughout the house, but doesn&rsquo;t active the heat pump. So it is very energy efficient. It was desirable to add control of this feature, after a little bit of research through ESPHome docs I found templates should help me achieve this goal. By defining a template fan, we can expose a fan controller to Apple, and when we receive control messages we can re-route them to control the A/C instead.</p><p>This is the configuration I added</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>climate</span>:
</span></span><span style=display:flex><span>  - <span style=color:#f92672>platform</span>: <span style=color:#ae81ff>daikin_ducted</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>id</span>: <span style=color:#ae81ff>daikin0</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>name</span>: <span style=color:#e6db74>&#34;Ducted AC&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>on_state</span>:
</span></span><span style=display:flex><span>      <span style=color:#f92672>then</span>:
</span></span><span style=display:flex><span>        <span style=color:#f92672>lambda</span>: |-<span style=color:#e6db74>
</span></span></span><span style=display:flex><span><span style=color:#e6db74>          auto call = id(templatefan0).make_call();
</span></span></span><span style=display:flex><span><span style=color:#e6db74>          call.set_state(x.mode == climate::CLIMATE_MODE_FAN_ONLY);
</span></span></span><span style=display:flex><span><span style=color:#e6db74>          
</span></span></span><span style=display:flex><span><span style=color:#e6db74>          if(x.fan_mode == climate::CLIMATE_FAN_LOW)
</span></span></span><span style=display:flex><span><span style=color:#e6db74>            call.set_speed(1);
</span></span></span><span style=display:flex><span><span style=color:#e6db74>          else if(x.fan_mode == climate::CLIMATE_FAN_MEDIUM)
</span></span></span><span style=display:flex><span><span style=color:#e6db74>            call.set_speed(2);
</span></span></span><span style=display:flex><span><span style=color:#e6db74>          else if(x.fan_mode == climate::CLIMATE_FAN_HIGH)
</span></span></span><span style=display:flex><span><span style=color:#e6db74>            call.set_speed(3);
</span></span></span><span style=display:flex><span><span style=color:#e6db74>
</span></span></span><span style=display:flex><span><span style=color:#e6db74>          if(  id(templatefan0).speed != call.get_speed() 
</span></span></span><span style=display:flex><span><span style=color:#e6db74>            || id(templatefan0).state != call.get_state())
</span></span></span><span style=display:flex><span><span style=color:#e6db74>            call.perform();</span>          
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>fan</span>:
</span></span><span style=display:flex><span>  - <span style=color:#f92672>platform</span>: <span style=color:#ae81ff>template</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>name</span>: <span style=color:#e6db74>&#34;Ducted Fan&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>id</span>: <span style=color:#ae81ff>templatefan0</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>speed_count</span>: <span style=color:#ae81ff>3</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>on_state</span>:
</span></span><span style=display:flex><span>      <span style=color:#f92672>then</span>:
</span></span><span style=display:flex><span>        <span style=color:#f92672>lambda</span>: |-<span style=color:#e6db74>
</span></span></span><span style=display:flex><span><span style=color:#e6db74>          auto call = id(daikin0).make_call();
</span></span></span><span style=display:flex><span><span style=color:#e6db74>          call.set_mode(x-&gt;state ? &#34;FAN_ONLY&#34; : &#34;OFF&#34;);
</span></span></span><span style=display:flex><span><span style=color:#e6db74>
</span></span></span><span style=display:flex><span><span style=color:#e6db74>          if(id(daikin0).mode != call.get_mode())
</span></span></span><span style=display:flex><span><span style=color:#e6db74>            call.perform();</span>          
</span></span><span style=display:flex><span>    <span style=color:#f92672>on_speed_set</span>:
</span></span><span style=display:flex><span>      <span style=color:#f92672>then</span>:
</span></span><span style=display:flex><span>        <span style=color:#f92672>lambda</span>: |-<span style=color:#e6db74>
</span></span></span><span style=display:flex><span><span style=color:#e6db74>          auto call = id(daikin0).make_call();
</span></span></span><span style=display:flex><span><span style=color:#e6db74>          switch(x) {
</span></span></span><span style=display:flex><span><span style=color:#e6db74>            case 1: call.set_fan_mode(&#34;LOW&#34;); break;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>            case 2: call.set_fan_mode(&#34;MEDIUM&#34;); break;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>            case 3: call.set_fan_mode(&#34;HIGH&#34;); break;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>            default: break;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>          }
</span></span></span><span style=display:flex><span><span style=color:#e6db74>
</span></span></span><span style=display:flex><span><span style=color:#e6db74>          if(id(daikin0).fan_mode != call.get_fan_mode())
</span></span></span><span style=display:flex><span><span style=color:#e6db74>            call.perform();</span>          
</span></span></code></pre></div><p>The lambdas contain C++ snippets which marshal across the FAN_ONLY control of the A/C to and from the template fan. Care is needed to check and only perform the <code>call()</code> action on new data. Otherwise a loop is formed where each devices on_state lambda calls the other on_state lambda.</p><p>With this extra yaml code in place, an extra fan device appears in the Apple Home app. It shows the status if the A/C in fan only mode, and enables control from iOS.</p><figure><img srcset="/posts/daikin-esp-001/images/027_hu2296917638378160297.png 390w,
/posts/daikin-esp-001/images/027_hu15801060254245723884.png 800w,
/posts/daikin-esp-001/images/027_hu14618525017028231603.png 2160w" src=/posts/daikin-esp-001/images/027_hu15801060254245723884.png alt></figure><h1 id=idf-bugs>IDF bugs<a hidden class=anchor aria-hidden=true href=#idf-bugs>#</a></h1><p>The system has been working great for a few months on the custom hardware, hidden away in the wall. However when adding the new fan only features I noticed that the firmware was reporting a CRC error on a specific message, I added some extra debugging messages to get a bit more insight into the issue. Every 5 minutes the main controller sends a request for the heat-pumps name (message type A1h). When the heat pump responds the message the ESP tries to decode ends up corrupted.</p><pre tabindex=0><code>[10:16:19][VV][homebus:217][rmt_rx]: rx: (len=768, buffer=0x3fc99358)
[10:16:19][VV][homebus:088][rmt_rx]: l=20 [00 00 a1 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 45]
[10:16:19][VV][homebus:217][rmt_rx]: rx: (len=1016, buffer=0x3fc99098)
[10:16:19][VV][homebus:088][rmt_rx]: l=30 [00 00 00 00 00 00 00 00 00 45 40 00 a1 00 52 5a 51 31 30 30 4c 56 31 00 00 00 00 00 00 58]
[10:16:19][E][daikin_ducted.climate:062][rmt_rx]: Packet CRC error 58 != 3f (length = 30)
[10:16:19][VV][esp-idf:000][rmt_rx]: I (300093) daikin_ducted.climate: 0x3fca4070   00 00 00 00 00 00 00 00  00 45 40 00 a1 00 52 5a  |.........E@...RZ|

[10:16:19][VV][esp-idf:000][rmt_rx]: I (300096) daikin_ducted.climate: 0x3fca4080   51 31 30 30 4c 56 31 00  00 00 00 00 00 58 00 00  |Q100LV1......X..|

[10:16:19][VV][homebus:217][rmt_rx]: rx: (len=736, buffer=0x3fc99498)
[10:16:19][VV][homebus:088][rmt_rx]: l=23 [00 f0 35 52 5a 51 31 30 30 4c 56 31 00 00 00 00 00 00 00 00 00 00 67]
[10:16:19][I][daikin_ducted.climate:317][rmt_rx]: Outside Name(0x35): RZQ100LV1
</code></pre><p>The message is not directed at us, so it&rsquo;s not actually essential that we decode it, but I still wanted to work out the issue, and fix it. Incase it caused issues with other messages that we do need to handle. To provide a bit more info for debugging I took the controller out of the wall and hooked up the saleae again, and took a capture alongside the log recorded by the ESP.</p><figure><img srcset="/posts/daikin-esp-001/images/025_hu7737790677115205696.png 390w,
/posts/daikin-esp-001/images/025_hu11293403843814654311.png 800w,
/posts/daikin-esp-001/images/025_hu11627923489367223617.png 2160w" src=/posts/daikin-esp-001/images/025_hu11293403843814654311.png alt></figure><p>This capture confirmed the messages were transmitted correctly over the bus, so the issue is on the ESP side.</p><pre tabindex=0><code>Actual messages on bus:
[00 00 a1 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 45]      
[40 00 a1 00 52 5a 51 31 30 30 4c 56 31 00 00 00 00 00 00 58]
</code></pre><p>The RMT peripheral in the ESP is what I&rsquo;m using to capture the bus. It combines a counter and edge detection to store timestamps of high/low transitions. This takes a large ISR overhead off the processor, by configuring a timeout value you can receive an interrupt while mid-packet if the buffers fill, or at the end of a packet. Here is a diagram from the ESP32C3 reference manual describing the peripheral.</p><figure><img srcset="/posts/daikin-esp-001/images/026_hu6829802254266549080.png 390w,
/posts/daikin-esp-001/images/026_hu4026284374212730921.png 800w,
/posts/daikin-esp-001/images/026_hu4732278606138768800.png 2160w" src=/posts/daikin-esp-001/images/026_hu4026284374212730921.png alt></figure><p>Note that the RAM for the peripheral is dedicated and listed as 192 * 32bit. This is split into 4 blocks each 48 * 32bits in size. Each 32bit word stores 2 transitions/periods. So in a single block of RMT RAM we can save 96 edges of data, before an interrupt routine needs to take over and empty that data. The ESP-IDF driver for RMT takes care of this step for us. The transitions are stored in a system memory buffer that is passed to our application only once a timeout event happens.</p><p>This took me a few hours to figure out, but keen eyed readers might have started to piece together the issue. In my extra debugging info listed above I record the length and buffer address of the raw RMT data before processing. The first buffer is 768 bytes in length. This is 384 edges; 192 falling, and 192 rising. This means the packet is an exact multiple of the RMT RAM blocks.
Two more pieces of the puzzle:</p><ul><li>On a timeout, the RMT peripheral inserts an entry with a period of 0 to indicate the end of an RMT packet into it&rsquo;s RAM.</li><li>In ESP-IDF v4.4.8, the RMT driver interrupt processes the timeout flag before the buffer threshold flag.</li></ul><p>Have you worked out the bug with these clues?</p><p>In my case I&rsquo;ve configured the RX2 channel to make use of 2 RAM blocks, the driver configures the <code>RMT_CH2_RX_LIM_REG</code> to 48 (one RAM block) in this case. Consider what happens if a RMT RAM block is filled with data, but hasn&rsquo;t rolled over the <code>RMT_CH2_RX_LIM_REG</code> yet, so a <code>RXT_CH2_RX_THR_EVENT_INT</code> hasn&rsquo;t occurred, but will occur if another edge is seen. We&rsquo;re at the end of a packet, so not more edge will be seen. The hardware detects a timeout, so inserts a <code>0</code> period into the buffer. This simultaneously produces a <code>RXT_CH2_RX_THR_EVENT_INT</code> and <code>RMT_CH2_RX_END_INT</code>.</p><pre tabindex=0><code>1. The drivers interrupt handler runs and sees the `RMT_CH2_RX_END_INT` status so it handles that and passes data to our application, which results in this buffer.
[00 00 a1 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 45]

2. It continues through the interrupt routine and starts processing the `RXT_CH2_RX_THR_EVENT_INT` interrupt.
   48 words of RMT data is stored in the driver SRAM buffer
[00 00 00 00 00 00 00 00 00 45 ... 

3. The next packet arrives and is appended to the erroneous data left over by the bug.
... 40 00 a1 00 52 5a 51 31 30 30 4c 56 31 00 00 00 00 00 00 58]
</code></pre><p>I&rsquo;m currently stuck on IDF v4, as this is what ESPHome is still using, and per Espressif&rsquo;s support terms they ceased bugfix releases in July 2024 with the release of v4.4.8.
An easy fix for this is to clear the <code>RXT_CH2_RX_THR_EVENT_INT</code> status if we handle a <code>RMT_CH2_RX_END_INT</code> even in the same interrupt routine. However since bugfixes in the SDK won&rsquo;t be accepted now, I&rsquo;ve implemented a fix that works in my use case at the application level.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>rmt_item32_t</span> <span style=color:#f92672>*</span>items <span style=color:#f92672>=</span> (<span style=color:#66d9ef>rmt_item32_t</span> <span style=color:#f92672>*</span>)<span style=color:#a6e22e>xRingbufferReceive</span>(rb, <span style=color:#f92672>&amp;</span>length, portMAX_DELAY);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// ESP-IDF bug, if rx_end completes on a rx_lim boundary, writing of an rx_end marker 
</span></span></span><span style=display:flex><span><span style=color:#75715e>// triggers the rx_thresh interrupt and affixes the end of this packet to the start of the next.
</span></span></span><span style=display:flex><span><span style=color:#75715e>// Can&#39;t be fixed in IDF as 4.4.8 isn&#39;t getting any additional bug fixes.
</span></span></span><span style=display:flex><span><span style=color:#75715e>// As configured this boundary is 384 bytes. Re-starting the rmt_rx resets the buffer pointers.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>if</span>((length <span style=color:#f92672>%</span> <span style=color:#ae81ff>384</span>) <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>){
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>esp_err_t</span> error <span style=color:#f92672>=</span> <span style=color:#a6e22e>rmt_rx_start</span>(RMT_CHANNEL_2, true);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (error <span style=color:#f92672>!=</span> ESP_OK)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>ESP_LOGE</span>(TAG, <span style=color:#e6db74>&#34;Restart of rmt_rx failed&#34;</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> (items)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#75715e>// process RMT data
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><p>This is a pretty clean fix. This does create a period where packets may not be detected, but the Daikin protocol leaves 10-20ms between packets so this isn&rsquo;t an issue in this case. And we now correctly receive packets that are a multiple of RMT RAM size!</p><pre tabindex=0><code>[09:56:17][VV][homebus:217][rmt_rx]: rx: (len=768, buffer=0x3fc99348)
[09:56:17][VV][homebus:088][rmt_rx]: l=20 [00 00 a1 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 45]
[09:56:17][VV][homebus:217][rmt_rx]: rx: (len=632, buffer=0x3fc99098)
[09:56:17][VV][homebus:088][rmt_rx]: l=20 [40 00 a1 00 52 5a 51 31 30 30 4c 56 31 00 00 00 00 00 00 58]
[09:56:17][VV][homebus:217][rmt_rx]: rx: (len=736, buffer=0x3fc99318)
[09:56:17][VV][homebus:088][rmt_rx]: l=23 [00 f0 35 52 5a 51 31 30 30 4c 56 31 00 00 00 00 00 00 00 00 00 00 67]
[09:56:17][I][daikin_ducted.climate:317][rmt_rx]: Outside Name(0x35): RZQ100LV1
</code></pre><h1 id=conclusion>Conclusion<a hidden class=anchor aria-hidden=true href=#conclusion>#</a></h1><p>Thanks for reading along with this journey.
If you&rsquo;re after an assembled device to control your A/C check out the hardware currently sold at the <a href=https://github.com/Arnold-n/P1P2MQTT>P1P2MQTT project</a>, when I started the hardware wasn&rsquo;t quite doing what I wanted, but it&rsquo;s come a long way and would have just worked for my A/C.</p><h2 id=downloads>Downloads<a hidden class=anchor aria-hidden=true href=#downloads>#</a></h2><p>If you want to download the circuit designs or ESPHome firmware that I&rsquo;ve created it&rsquo;s open source licensed and available. I&rsquo;d love to hear if you&rsquo;re able to add some smarts to your ducted air conditioners. I&rsquo;m not planning on selling assembled units of this design.</p><h2 id=max22088-breakout-hb-bob-design>MAX22088 breakout &ldquo;hb-bob&rdquo; design:<a hidden class=anchor aria-hidden=true href=#max22088-breakout-hb-bob-design>#</a></h2><ul><li><a href=https://github.com/gregdavill/daikin-esp/tree/main/pcb/hb-bob/kicad-src>KiCad source</a></li><li><a href=https://github.com/gregdavill/daikin-esp/tree/main/pcb/hb-bob>Gebrers/Schematic</a></li></ul><h2 id=esp32c3-addon-esp-daikin-design>ESP32C3 addon esp-daikin design:<a hidden class=anchor aria-hidden=true href=#esp32c3-addon-esp-daikin-design>#</a></h2><ul><li><a href=https://github.com/gregdavill/daikin-esp/tree/main/pcb/esp-daikin/kicad-src>KiCad source</a></li><li><a href=https://github.com/gregdavill/daikin-esp/tree/main/pcb/esp-daikin>Gebrers/Schematic</a></li></ul><h2 id=esphome-yamlcustom-c-component>ESPHome yaml/Custom C++ component<a hidden class=anchor aria-hidden=true href=#esphome-yamlcustom-c-component>#</a></h2><ul><li><a href=https://github.com/gregdavill/daikin-esp/tree/main/esphome>https://github.com/gregdavill/daikin-esp/tree/main/esphome</a></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://gregdavill.com/tags/esp32/>ESP32</a></li><li><a href=https://gregdavill.com/tags/esp32c3/>ESP32C3</a></li><li><a href=https://gregdavill.com/tags/esphome/>Esphome</a></li><li><a href=https://gregdavill.com/tags/homeassistant/>Homeassistant</a></li></ul><nav class=paginav><a class=next href=https://gregdavill.com/posts/2022-07-18-new-d20-panels/><span class=title>Next »</span><br><span>d20: Panel Photos</span></a></nav></footer><div id=hyvor-talk-view></div><script type=text/javascript>dark_palette={accent:"#ffffff",accentText:"#000000",footerHeader:"#1b1818",footerHeaderText:"#cac7c7",box:"#232121",boxText:"#ffffff",boxLightText:"#aaaaaa",backgroundText:"#ffffff"},light_palette={accent:"#659DBD",accentText:"#FFFFFF",footerHeader:"#FAFAFA",footerHeaderText:"#484848",box:"#FFFFFF",boxText:"#111111",boxLightText:"#AAAAAA",backgroundText:"#111111"};var HYVOR_TALK_WEBSITE,HYVOR_TALK_CONFIG,palette=light_palette;document.body.className.includes("dark")&&(palette=dark_palette),HYVOR_TALK_WEBSITE=5683,HYVOR_TALK_CONFIG={url:!1,id:"94c1db0f3e829c6480131973207f1826",palette},document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?hyvor_talk.setPalette(light_palette):hyvor_talk.setPalette(dark_palette)})</script><script async type=text/javascript src=//talk.hyvor.com/web-api/embed.js></script></article></main><footer class=footer><span>&copy; 2024 <a href=https://gregdavill.com/>Greg Davill's Projects</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script src=https://cdnjs.cloudflare.com/ajax/libs/medium-zoom/1.0.6/medium-zoom.min.js integrity="sha512-N9IJRoc3LaP3NDoiGkcPa4gG94kapGpaA5Zq9/Dr04uf5TbLFU5q0o8AbRhLKUUlp8QFS2u7S+Yti0U7QtuZvQ==" crossorigin=anonymous referrerpolicy=no-referrer></script><script>light_bg="rgb(255, 255, 255)",dark_bg="rgb(29, 30, 32)";var palette_bg=light_bg;document.body.className.includes("dark")&&(palette_bg=dark_bg),document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?palette_bg=light_bg:palette_bg=dark_bg;const e=Array.from(document.querySelectorAll(".post-content img"));e.forEach(e=>{mediumZoom(e,{margin:0,background:palette_bg,scrollOffset:40,container:null,template:null})})});const images=Array.from(document.querySelectorAll(".post-content img"));images.forEach(e=>{mediumZoom(e,{margin:0,background:palette_bg,scrollOffset:40,container:null,template:null})})</script><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>