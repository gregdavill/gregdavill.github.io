<!doctype html><html lang=en dir=auto>
<head><meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="IE=edge">
<meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no">
<meta name=robots content="index, follow">
<title>Boson Frame Grabber Part 3 | Greg Davill's Projects</title>
<meta name=keywords content="boson,boson-frame-grabber,thermal">
<meta name=description content="In this part I want to talk about the firmware, or code, this device will need in order to operate as I want.">
<meta name=author content>
<link rel=canonical href=https://gregdavill.github.io/posts/boson-frame-grabber-pt3/>
<link crossorigin=anonymous href=/assets/css/stylesheet.min.816ea52b2e5efb0acabe4abc1e8acdc36ac6408314ac983cae9fb1a47e53c995.css integrity="sha256-gW6lKy5e+wrKvkq8HorNw2rGQIMUrJg8rp+xpH5TyZU=" rel="preload stylesheet" as=style>
<script defer crossorigin=anonymous src=/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5+kdJvBz5iKbt6B5PJI=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://gregdavill.github.io/favicon.ico>
<link rel=icon type=image/png sizes=16x16 href=https://gregdavill.github.io/favicon-16x16.png>
<link rel=icon type=image/png sizes=32x32 href=https://gregdavill.github.io/favicon-32x32.png>
<link rel=apple-touch-icon href=https://gregdavill.github.io/apple-touch-icon.png>
<link rel=mask-icon href=https://gregdavill.github.io/safari-pinned-tab.svg>
<meta name=theme-color content="#2e2e33">
<meta name=msapplication-TileColor content="#2e2e33">
<meta name=generator content="Hugo 0.89.4">
<noscript>
<style>#theme-toggle,.top-link{display:none}</style>
<style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style>
</noscript><meta property="og:title" content="Boson Frame Grabber Part 3">
<meta property="og:description" content="In this part I want to talk about the firmware, or code, this device will need in order to operate as I want.">
<meta property="og:type" content="article">
<meta property="og:url" content="https://gregdavill.github.io/posts/boson-frame-grabber-pt3/">
<meta property="og:image" content="https://gregdavill.github.io/images/Db3zQfKV4AATwsY.jpg"><meta property="article:section" content="posts">
<meta property="article:published_time" content="2018-06-22T00:00:00+00:00">
<meta property="article:modified_time" content="2018-06-22T00:00:00+00:00">
<meta name=twitter:card content="summary_large_image">
<meta name=twitter:image content="https://gregdavill.github.io/images/Db3zQfKV4AATwsY.jpg">
<meta name=twitter:title content="Boson Frame Grabber Part 3">
<meta name=twitter:description content="In this part I want to talk about the firmware, or code, this device will need in order to operate as I want.">
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://gregdavill.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Boson Frame Grabber Part 3","item":"https://gregdavill.github.io/posts/boson-frame-grabber-pt3/"}]}</script>
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Boson Frame Grabber Part 3","name":"Boson Frame Grabber Part 3","description":"In this part I want to talk about the firmware, or code, this device will need in order to operate as I want.\n","keywords":["boson","boson-frame-grabber","thermal"],"articleBody":"In this part I want to talk about the firmware, or code, this device will need in order to operate as I want.\nBut before I get to that lets take a quick step backwards to some back of the envelope engineering I did when I was thinking about the hardware required to save an image from the camera.\nData Flow The Boson is designed to stream images out automatically, the camera has a control interface, but you cannot simply ask it to ‚Äúsnap‚Äù a photo, and read it out byte by byte. Instead it just rudely spews out data. It has a 16bit bus running with a 13.5MHz pixel clock. This equates to a bus speed of 27MByte/s. Luckily for us pixel data on this bus comes in bursts, before and after each line of valid data there is a gap and after every line in a frame has been transmitted there is a few lines blank. These are Horizontal and vertical blanking periods designed to give electronics some time to process the information. (My understanding is that originally these were to give CRT screens time to energize coils and steer the electron beam back to be ready for the start of the next row. But they are still common place in many video formats.)\n  I decided to add high speed RAM to the design in order to ensure I could reliably capture the video frame. I have used SD cards in the past and it is pretty common place for them to have variable delays when writing data blocks to them as they perform various internal operations. If I could get away with bypassing the RAM in the final design great, but I still wanted it in the hardware.\nOne benefit of using the RAM is that it doesn‚Äôt matter what speed the SD card is running at this makes life easier. I can develop the modules that are needed to run the system then leave as much optimization till the end.\nVerilog \u0026 PicoSoC Code that describes hardware. As mentioned this is my first FPGA project. I had already selected the iCE40HX8K as it was the largest ICE40 in the smallest package. This particular FPGA has 8k LUTs. I didn‚Äôt know how many LUTs my design would require. Is 8k alot? What is a LUT? I‚Äôm not going to go into FPGA basics, but from my experience 8k is enough to implement a RISCV 32 bit processor and a handful of basic peripherals. It is enough to get your feet wet in a real FPGA project!\n  I had chosen the ICE40 as a target device because I was reading about a free open source FPGA tool-chain ice-storm. I followed the guides and examples and got a LED blinking on the back of my board! This project was on it‚Äôs feet. But I was still a bit outside my comfort zone.\nClaire Xen is the creator of the icestorm project. She also created a lightweight RISCV processor called picorv32. More importantly for me (A verilog newbie) she packaged this into PicoSoC.\n  PicoSoC is a combination of the RISCV CPU picorv32, a flash memory controller for reading in program data, some SRAM, and a UART serial port. Also an example built on the Lattice HX8K evaluation board! The processor let you write C code and using memory mapped register directly control and monitor bits in your custom hardware. it was a perfect way for me to ease into FPGA design. PicoSoC has some great step by step instructions in order to compile and get it loaded, one of the steps is downloading and compiling a RISCV variant of GCC. This went smoothly but was the slowest port (~4 hours on my slow laptop.) The wait was worth it, because after it finished I had PicoSoC loaded and running on my custom hardware. The UART link to the PC gives you a very simple text console which I think is perfect for adding to and modifying in firmware. (Love the PicoSoC splash screen btw Clifford!)\nThink Modular   Verilog is constructed as a very hierarchical language. Which means when developing systems for FPGAs you should be thinking about modules, how can you split your design into modular blocks that fit together. I envisioned a system as shown above, I had now validated that the FPGA was functioning, SPI FLASH and programming worked, and my User I/O and LED worked. I wanted to write some logic to test the SD card, HyperRAM, and Boson Interface. Any of these could have a hardware bug in the PCB design that could render this prototype useless.\nBoson IF I wrote the Boson Interface first as a basic FIFO, using commands in the SoC‚Äôs firmware I was able to reset the FIFO and print out 16 values that had appeared from the camera over serial. This with a combination of holding my hand in front of the camera indicated that data was been read correctly from the camera.\nHyperRAM I had started working on a hyperRAM module with my first prototype hardware. However I didn‚Äôt really understand what interfaces I would need to support the burst style data that the RAM needs in order to sustain it‚Äôs read speeds. At this time I saw Kevin Hubbard from Black Mesa labs had just released an open source HyperRAM library, His library relies on dividing the clock rate by 4 to properly generate the DDR signal timings without having to worry about device specific PLLs. With a bit of reading though his very well documented code I was able to add his module to the PicoSoC system bus and test the RAM using some simple functions in C.\nMicro SD \u0026 FAT   The biggest benefit of using a softcore processor in my design in my opinion was the ability to leverage existing open source software projects. FatFs is one of those projects, I‚Äôve used it on countless projects in the past. The example projects include a ‚Äúbarebones‚Äù implementation of the low level control using bit-banged IO. In order to get this to work I just had to extend the GPIO registers from write only to R/W and map them to the SD card pinout in verilog. With those small changes* I was able to write a file to the SD card!\n*I spent an entire evening scratching my head as to why FatFs wasn‚Äôt working. As soon as I looked at the memory-map output from GCC I worked out why, I think one of the goals of PicoSoC is to be simple enough to get up and running fast. Because of this the example firmware (what my code was based off) only utilized the RAM on the stack, the linker never declared where to store static/global variables, and the startup code never initialized these. I did a few unspeakable linker-hacks to get it to work initally. A better solution is to use the code provided by Miodrag Milanoviƒá, Who did a great job porting microPython to the picoSoC.\nPick Your Battles Now with each hardware component tested to be working I knew the hardware should be capable of capturing an image from the camera, I just had to tell it how to do it.\n  My idea for a simple capture sequence is as follows:\n On powerup Boson IF module has control over the HyperRAM. The CPU tries to access the HyperRAM and becomes stalled. The Boson IF waits for a Vsync pulse to synchronize with the image. It captures an image through a Dual-clock FIFO. (Boson Camera Controls the pixel clock) A small state-machine empties the FIFO. After 3202562 bytes the state-machine in Boson IF releases the HyperRAM. CPU takes over and using FatFS writes an image to the SD card.    To my surprise this worked! Not ideal though, you had to restart the camera to take a new photo, the SD card was still slow, and it would over-write the last photo you took.\n   You can see a few errors with this photo, firstly I miss-judged what the focal distance would see. There is a 2 pixel band on the left image that‚Äôs actually pixels from start of the next line. I messed up the endian-ness so every pair of pixels is flipped. Still a success!!  Optimise When Ready I systematically went through and added performance to each module.\n HyperRAM got updated to make use of the DDR IO and PLL in the ICE40. SD driver got updated to a hardware SPI module running at 12MHz. Control registers added to the Boson IF to enable capture through the picoSoC terminal. Lastly I added a simple DMA to copy data from the HyperRAM out into the SD card without requiring the CPU. This greatly improved performance.  I reduced the time to save an 320x256 image from ~12s to ~0.3s.\nMoving Forward At this point I‚Äôve run out of space inside the ICE40HX8K. I‚Äôm sure there is room to optimise the current design, but it is very difficult to add extra features. In order to push the performance even further I will need to swap the SD SPI driver for a real SD 4-bit interface. There are a few open source versions but none of them fit. Time to look for a bigger FPGA?\n  Up to this point I had I had been working with a Boson 320x256 9Hz I‚Äôve borrowed from work. GroupGets a FLIR distributor among other things offered to send me a Boson 640x512 60Hz model! Amazing! If you‚Äôre interested in picking up a Boson Camera check out their range!\n  Unfortunately the Camera running at 60Hz outputs data too fast for the logic in my HX8K board to keep up with. It‚Äôs pixel clock is 27MHz at 60Hz which corresponds to a 54MByte/s bus speed. The FIFO can capture this but my HyperRAM bus is not able to sustain a data rate to be ready by the next line. But by enabling the average in the camera the frame rate is reduced to 30Hz and the clock brought down to 13.5MHz, with some small tweaks I was able to capture this frame. (95 degree FOV is VERY wide!)\n  I have plans to create an updated version featuring a more power processor capable of handling both the Boson 320 and Boson 640. Stay tuned for more details about this in Part 4!\nHere is a teaser! üòâ\n   ","wordCount":"1730","inLanguage":"en","image":"https://gregdavill.github.io/images/Db3zQfKV4AATwsY.jpg","datePublished":"2018-06-22T00:00:00Z","dateModified":"2018-06-22T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://gregdavill.github.io/posts/boson-frame-grabber-pt3/"},"publisher":{"@type":"Organization","name":"Greg Davill's Projects","logo":{"@type":"ImageObject","url":"https://gregdavill.github.io/favicon.ico"}}}</script>
</head>
<body id=top>
<script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add('dark'):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove('dark'):window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script>
<header class=header>
<nav class=nav>
<div class=logo>
<a href=https://gregdavill.github.io/ accesskey=h title="Greg Davill's Projects (Alt + H)">Greg Davill's Projects</a>
<span class=logo-switches>
<button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg>
</button>
</span>
</div>
<ul id=menu>
<li>
<a href=https://gregdavill.github.io/archives title=Archive>
<span>Archive</span>
</a>
</li>
<li>
<a href=https://gregdavill.github.io/categories/ title=Categories>
<span>Categories</span>
</a>
</li>
<li>
<a href=https://gregdavill.github.io/search/ title="Search (Alt + /)" accesskey=/>
<span>Search</span>
</a>
</li>
<li>
<a href=https://gregdavill.github.io/tags/ title=Tags>
<span>Tags</span>
</a>
</li>
</ul>
</nav>
</header>
<main class=main>
<article class=post-single>
<header class=post-header>
<div class=breadcrumbs><a href=https://gregdavill.github.io/>Home</a>&nbsp;¬ª&nbsp;<a href=https://gregdavill.github.io/posts/>Posts</a></div>
<h1 class=post-title>
Boson Frame Grabber Part 3
</h1>
<div class=post-meta><span title="2018-06-22 00:00:00 +0000 UTC">June 22, 2018</span>&nbsp;¬∑&nbsp;9 min&nbsp;|&nbsp;<a href=https://github.com/gregdavill/gregdavill.github.io/blob/main/blog-src/content/posts/boson-frame-grabber-pt3/index.md rel="noopener noreferrer" target=_blank>Suggest Changes</a>
</div>
</header>
<div class=post-content><p>In this part I want to talk about the firmware, or code, this device will need in order to operate as I want.</p>
<p>But before I get to that lets take a quick step backwards to some back of the envelope engineering I did when I was thinking about the hardware required to save an image from the camera.</p>
<h2 id=data-flow>Data Flow<a hidden class=anchor aria-hidden=true href=#data-flow>#</a></h2>
<p>The Boson is designed to stream images out automatically, the camera has a control interface, but you cannot simply ask it to &ldquo;snap&rdquo; a photo, and read it out byte by byte. Instead it just rudely spews out data. It has a 16bit bus running with a 13.5MHz pixel clock. This equates to a bus speed of 27MByte/s. Luckily for us pixel data on this bus comes in bursts, before and after each line of valid data there is a gap and after every line in a frame has been transmitted there is a few lines blank. These are Horizontal and vertical blanking periods designed to give electronics some time to process the information. (My understanding is that originally these were to give CRT screens time to energize coils and steer the electron beam back to be ready for the start of the next row. But they are still common place in many video formats.)</p>
<figure>
<a href=/posts/boson-frame-grabber-pt3/images/image-asset.png>
<img srcset="/posts/boson-frame-grabber-pt3/images/image-asset_hua1dce23e4511d10f4aa7aec0b1691be8_15386_320x0_resize_box_3.png 320w,
/posts/boson-frame-grabber-pt3/images/image-asset_hua1dce23e4511d10f4aa7aec0b1691be8_15386_600x0_resize_box_3.png 600w,
/posts/boson-frame-grabber-pt3/images/image-asset_hua1dce23e4511d10f4aa7aec0b1691be8_15386_1200x0_resize_box_3.png 2x" src=/posts/boson-frame-grabber-pt3/images/image-asset_hua1dce23e4511d10f4aa7aec0b1691be8_15386_600x0_resize_box_3.png alt>
</a>
</figure>
<p>I decided to add high speed RAM to the design in order to ensure I could reliably capture the video frame. I have used SD cards in the past and it is pretty common place for them to have variable delays when writing data blocks to them as they perform various internal operations. If I could get away with bypassing the RAM in the final design great, but I still wanted it in the hardware.</p>
<p>One benefit of using the RAM is that it doesn&rsquo;t matter what speed the SD card is running at this makes life easier. I can develop the modules that are needed to run the system then leave as much optimization till the end.</p>
<h2 id=verilog--picosoc>Verilog & PicoSoC<a hidden class=anchor aria-hidden=true href=#verilog--picosoc>#</a></h2>
<p>Code that describes hardware. As mentioned this is my first FPGA project. I had already selected the iCE40HX8K as it was the largest ICE40 in the smallest package. This particular FPGA has 8k LUTs. I didn&rsquo;t know how many LUTs my design would require. Is 8k alot? What is a LUT? I&rsquo;m not going to go into FPGA basics, but from my experience 8k is enough to implement a RISCV 32 bit processor and a handful of basic peripherals. It is enough to get your feet wet in a real FPGA project!</p>
<figure>
<a href=/posts/boson-frame-grabber-pt3/images/Db2KUwcVwAAS-B8.jpg>
<img srcset="/posts/boson-frame-grabber-pt3/images/Db2KUwcVwAAS-B8_huae1158d7ea67a355493929ae20c247f1_263114_320x0_resize_q75_box.jpg 320w,
/posts/boson-frame-grabber-pt3/images/Db2KUwcVwAAS-B8_huae1158d7ea67a355493929ae20c247f1_263114_600x0_resize_q75_box.jpg 600w,
/posts/boson-frame-grabber-pt3/images/Db2KUwcVwAAS-B8_huae1158d7ea67a355493929ae20c247f1_263114_1200x0_resize_q75_box.jpg 2x" src=/posts/boson-frame-grabber-pt3/images/Db2KUwcVwAAS-B8_huae1158d7ea67a355493929ae20c247f1_263114_600x0_resize_q75_box.jpg alt>
</a>
</figure>
<p>I had chosen the ICE40 as a target device because I was reading about a free open source FPGA tool-chain ice-storm. I followed the guides and examples and got a LED blinking on the back of my board! This project was on it&rsquo;s feet. But I was still a bit outside my comfort zone.</p>
<p>Claire Xen is the creator of the <a href=https://github.com/YosysHQ/icestorm>icestorm</a> project. She also created a lightweight RISCV processor called <a href=https://github.com/cliffordwolf/picorv32>picorv32</a>. More importantly for me (A verilog newbie) she packaged this into <a href=https://github.com/cliffordwolf/picorv32/tree/master/picosoc>PicoSoC</a>.</p>
<figure>
<a href=/posts/boson-frame-grabber-pt3/images/Db3zQfKV4AATwsY.jpg>
<img srcset="/posts/boson-frame-grabber-pt3/images/Db3zQfKV4AATwsY_hu001b972a3129aabca1ad074de0328e97_303407_320x0_resize_q75_box.jpg 320w,
/posts/boson-frame-grabber-pt3/images/Db3zQfKV4AATwsY_hu001b972a3129aabca1ad074de0328e97_303407_600x0_resize_q75_box.jpg 600w,
/posts/boson-frame-grabber-pt3/images/Db3zQfKV4AATwsY_hu001b972a3129aabca1ad074de0328e97_303407_1200x0_resize_q75_box.jpg 2x" src=/posts/boson-frame-grabber-pt3/images/Db3zQfKV4AATwsY_hu001b972a3129aabca1ad074de0328e97_303407_600x0_resize_q75_box.jpg alt>
</a>
</figure>
<p>PicoSoC is a combination of the RISCV CPU picorv32, a flash memory controller for reading in program data, some SRAM, and a UART serial port. Also an example built on the Lattice HX8K evaluation board! The processor let you write C code and using memory mapped register directly control and monitor bits in your custom hardware. it was a perfect way for me to ease into FPGA design. PicoSoC has some great step by step instructions in order to compile and get it loaded, one of the steps is downloading and compiling a RISCV variant of GCC. This went smoothly but was the slowest port (~4 hours on my slow laptop.) The wait was worth it, because after it finished I had PicoSoC loaded and running on my custom hardware. The UART link to the PC gives you a very simple text console which I think is perfect for adding to and modifying in firmware. (Love the PicoSoC splash screen btw Clifford!)</p>
<h2 id=think-modular>Think Modular<a hidden class=anchor aria-hidden=true href=#think-modular>#</a></h2>
<figure>
<a href=/posts/boson-frame-grabber-pt3/images/Arch_001.png>
<img srcset="/posts/boson-frame-grabber-pt3/images/Arch_001_hu76ee797cc01d1b9026888db4f464cd44_13093_320x0_resize_box_3.png 320w,
/posts/boson-frame-grabber-pt3/images/Arch_001_hu76ee797cc01d1b9026888db4f464cd44_13093_600x0_resize_box_3.png 600w,
/posts/boson-frame-grabber-pt3/images/Arch_001_hu76ee797cc01d1b9026888db4f464cd44_13093_1200x0_resize_box_3.png 2x" src=/posts/boson-frame-grabber-pt3/images/Arch_001_hu76ee797cc01d1b9026888db4f464cd44_13093_600x0_resize_box_3.png alt>
</a>
</figure>
<p>Verilog is constructed as a very hierarchical language. Which means when developing systems for FPGAs you should be thinking about modules, how can you split your design into modular blocks that fit together. I envisioned a system as shown above, I had now validated that the FPGA was functioning, SPI FLASH and programming worked, and my User I/O and LED worked. I wanted to write some logic to test the SD card, HyperRAM, and Boson Interface. Any of these could have a hardware bug in the PCB design that could render this prototype useless.</p>
<h2 id=boson-if>Boson IF<a hidden class=anchor aria-hidden=true href=#boson-if>#</a></h2>
<p>I wrote the Boson Interface first as a basic FIFO, using commands in the SoC&rsquo;s firmware I was able to reset the FIFO and print out 16 values that had appeared from the camera over serial. This with a combination of holding my hand in front of the camera indicated that data was been read correctly from the camera.</p>
<h2 id=hyperram>HyperRAM<a hidden class=anchor aria-hidden=true href=#hyperram>#</a></h2>
<p>I had started working on a hyperRAM module with my first prototype hardware. However I didn&rsquo;t really understand what interfaces I would need to support the burst style data that the RAM needs in order to sustain it&rsquo;s read speeds. At this time I saw <a href=https://twitter.com/bml_khubbard>Kevin Hubbard</a> from Black Mesa labs had just released an open source <a href=https://github.com/blackmesalabs/hyperram>HyperRAM library</a>, His library relies on dividing the clock rate by 4 to properly generate the DDR signal timings without having to worry about device specific PLLs. With a bit of reading though his very well documented code I was able to add his module to the PicoSoC system bus and test the RAM using some simple functions in C.</p>
<h2 id=micro-sd--fat>Micro SD & FAT<a hidden class=anchor aria-hidden=true href=#micro-sd--fat>#</a></h2>
<figure>
<a href=/posts/boson-frame-grabber-pt3/images/DcBaf1YVAAAksdI.jpg>
<img srcset="/posts/boson-frame-grabber-pt3/images/DcBaf1YVAAAksdI_hu62d060813082a2ade33368a6d47844ce_211816_320x0_resize_q75_box.jpg 320w,
/posts/boson-frame-grabber-pt3/images/DcBaf1YVAAAksdI_hu62d060813082a2ade33368a6d47844ce_211816_600x0_resize_q75_box.jpg 600w,
/posts/boson-frame-grabber-pt3/images/DcBaf1YVAAAksdI_hu62d060813082a2ade33368a6d47844ce_211816_1200x0_resize_q75_box.jpg 2x" src=/posts/boson-frame-grabber-pt3/images/DcBaf1YVAAAksdI_hu62d060813082a2ade33368a6d47844ce_211816_600x0_resize_q75_box.jpg alt>
</a>
</figure>
<p>The biggest benefit of using a softcore processor in my design in my opinion was the ability to leverage existing open source software projects. <a href=http://elm-chan.org/fsw/ff/00index_e.html>FatFs</a> is one of those projects, I&rsquo;ve used it on countless projects in the past. The example projects include a &ldquo;barebones&rdquo; implementation of the low level control using bit-banged IO. In order to get this to work I just had to extend the GPIO registers from write only to R/W and map them to the SD card pinout in verilog. With those small changes* I was able to write a file to the SD card!</p>
<p>*I spent an entire evening scratching my head as to why FatFs wasn&rsquo;t working. As soon as I looked at the memory-map output from GCC I worked out why, I think one of the goals of PicoSoC is to be simple enough to get up and running fast. Because of this the example firmware (what my code was based off) only utilized the RAM on the stack, the linker never declared where to store static/global variables, and the startup code never initialized these. I did a few unspeakable linker-hacks to get it to work initally. A better solution is to use the code provided by <a href=https://github.com/cliffordwolf/picorv32/pull/61>Miodrag Milanoviƒá</a>, Who did a great job porting microPython to the picoSoC.</p>
<h2 id=pick-your-battles>Pick Your Battles<a hidden class=anchor aria-hidden=true href=#pick-your-battles>#</a></h2>
<p>Now with each hardware component tested to be working I knew the hardware should be capable of capturing an image from the camera, I just had to tell it how to do it.</p>
<figure>
<a href=/posts/boson-frame-grabber-pt3/images/Capture_001.png>
<img srcset="/posts/boson-frame-grabber-pt3/images/Capture_001_huf97249e3955b9bbb079fdc2eed92861c_11590_320x0_resize_box_3.png 320w,
/posts/boson-frame-grabber-pt3/images/Capture_001_huf97249e3955b9bbb079fdc2eed92861c_11590_600x0_resize_box_3.png 600w,
/posts/boson-frame-grabber-pt3/images/Capture_001_huf97249e3955b9bbb079fdc2eed92861c_11590_1200x0_resize_box_3.png 2x" src=/posts/boson-frame-grabber-pt3/images/Capture_001_huf97249e3955b9bbb079fdc2eed92861c_11590_600x0_resize_box_3.png alt>
</a>
</figure>
<p>My idea for a simple capture sequence is as follows:</p>
<ul>
<li>On powerup Boson IF module has control over the HyperRAM. The CPU tries to access the HyperRAM and becomes stalled.</li>
<li>The Boson IF waits for a Vsync pulse to synchronize with the image.</li>
<li>It captures an image through a Dual-clock FIFO. (Boson Camera Controls the pixel clock)</li>
<li>A small state-machine empties the FIFO.</li>
<li>After 320<em>256</em>2 bytes the state-machine in Boson IF releases the HyperRAM.</li>
<li>CPU takes over and using FatFS writes an image to the SD card.</li>
</ul>
<figure>
<a href=/posts/boson-frame-grabber-pt3/images/data-flow.png>
<img srcset="/posts/boson-frame-grabber-pt3/images/data-flow_hu5dca866d7380ed90b70a6300a8b50a2b_10899_320x0_resize_box_3.png 320w,
/posts/boson-frame-grabber-pt3/images/data-flow_hu5dca866d7380ed90b70a6300a8b50a2b_10899_600x0_resize_box_3.png 600w,
/posts/boson-frame-grabber-pt3/images/data-flow_hu5dca866d7380ed90b70a6300a8b50a2b_10899_1200x0_resize_box_3.png 2x" src=/posts/boson-frame-grabber-pt3/images/data-flow_hu5dca866d7380ed90b70a6300a8b50a2b_10899_600x0_resize_box_3.png alt>
</a>
</figure>
<p>To my surprise this worked! Not ideal though, you had to restart the camera to take a new photo, the SD card was still slow, and it would over-write the last photo you took.</p>
<figure>
<a href=/posts/boson-frame-grabber-pt3/images/Image_012.png>
<img srcset="/posts/boson-frame-grabber-pt3/images/Image_012_huf401e99e123da798a754b6642d6d6d07_22664_320x0_resize_box_3.png 320w,
/posts/boson-frame-grabber-pt3/images/Image_012_huf401e99e123da798a754b6642d6d6d07_22664_600x0_resize_box_3.png 600w,
/posts/boson-frame-grabber-pt3/images/Image_012_huf401e99e123da798a754b6642d6d6d07_22664_1200x0_resize_box_3.png 2x" src=/posts/boson-frame-grabber-pt3/images/Image_012_huf401e99e123da798a754b6642d6d6d07_22664_600x0_resize_box_3.png alt>
</a>
</figure>
<ul>
<li>You can see a few errors with this photo, firstly I miss-judged what the focal distance would see.</li>
<li>There is a 2 pixel band on the left image that&rsquo;s actually pixels from start of the next line.</li>
<li>I messed up the endian-ness so every pair of pixels is flipped.</li>
<li>Still a success!!</li>
</ul>
<h2 id=optimise-when-ready>Optimise When Ready<a hidden class=anchor aria-hidden=true href=#optimise-when-ready>#</a></h2>
<p>I systematically went through and added performance to each module.</p>
<ul>
<li>HyperRAM got updated to make use of the DDR IO and PLL in the ICE40.</li>
<li>SD driver got updated to a hardware SPI module running at 12MHz.</li>
<li>Control registers added to the Boson IF to enable capture through the picoSoC terminal.</li>
<li>Lastly I added a simple DMA to copy data from the HyperRAM out into the SD card without requiring the CPU. This greatly improved performance.</li>
</ul>
<p>I reduced the time to save an 320x256 image from ~12s to ~0.3s.</p>
<h2 id=moving-forward>Moving Forward<a hidden class=anchor aria-hidden=true href=#moving-forward>#</a></h2>
<p>At this point I&rsquo;ve run out of space inside the ICE40HX8K. I&rsquo;m sure there is room to optimise the current design, but it is very difficult to add extra features. In order to push the performance even further I will need to swap the SD SPI driver for a real SD 4-bit interface. There are a few open source versions but none of them fit. Time to look for a bigger FPGA?</p>
<figure>
<a href=/posts/boson-frame-grabber-pt3/images/De1tITuV4AAvTOP.jpg>
<img srcset="/posts/boson-frame-grabber-pt3/images/De1tITuV4AAvTOP_hu5438825b9b6d1014226d20d231e650c2_70055_320x0_resize_q75_box.jpg 320w,
/posts/boson-frame-grabber-pt3/images/De1tITuV4AAvTOP_hu5438825b9b6d1014226d20d231e650c2_70055_600x0_resize_q75_box.jpg 600w,
/posts/boson-frame-grabber-pt3/images/De1tITuV4AAvTOP_hu5438825b9b6d1014226d20d231e650c2_70055_1200x0_resize_q75_box.jpg 2x" src=/posts/boson-frame-grabber-pt3/images/De1tITuV4AAvTOP_hu5438825b9b6d1014226d20d231e650c2_70055_600x0_resize_q75_box.jpg alt>
</a>
</figure>
<p>Up to this point I had I had been working with a Boson 320x256 9Hz I&rsquo;ve borrowed from work. <a href=https://groupgets.com/>GroupGets</a> a FLIR distributor among other things offered to send me a Boson 640x512 60Hz model! Amazing! If you&rsquo;re interested in picking up a Boson Camera <a href=https://store.groupgets.com/collections/flir-boson-accessories>check out their range</a>!</p>
<figure>
<a href=/posts/boson-frame-grabber-pt3/images/De1tITtUYAELhJM.jpg>
<img srcset="/posts/boson-frame-grabber-pt3/images/De1tITtUYAELhJM_hu5438825b9b6d1014226d20d231e650c2_73607_320x0_resize_q75_box.jpg 320w,
/posts/boson-frame-grabber-pt3/images/De1tITtUYAELhJM_hu5438825b9b6d1014226d20d231e650c2_73607_600x0_resize_q75_box.jpg 600w,
/posts/boson-frame-grabber-pt3/images/De1tITtUYAELhJM_hu5438825b9b6d1014226d20d231e650c2_73607_1200x0_resize_q75_box.jpg 2x" src=/posts/boson-frame-grabber-pt3/images/De1tITtUYAELhJM_hu5438825b9b6d1014226d20d231e650c2_73607_600x0_resize_q75_box.jpg alt>
</a>
</figure>
<p>Unfortunately the Camera running at 60Hz outputs data too fast for the logic in my HX8K board to keep up with. It&rsquo;s pixel clock is 27MHz at 60Hz which corresponds to a 54MByte/s bus speed. The FIFO can capture this but my HyperRAM bus is not able to sustain a data rate to be ready by the next line. But by enabling the average in the camera the frame rate is reduced to 30Hz and the clock brought down to 13.5MHz, with some small tweaks I was able to capture this frame. (95 degree FOV is VERY wide!)</p>
<figure>
<a href=/posts/boson-frame-grabber-pt3/images/De11m5cV4AAH2np.jpg>
<img srcset="/posts/boson-frame-grabber-pt3/images/De11m5cV4AAH2np_hu4b3b9a0da469793a0db5610b3338de55_37768_320x0_resize_q75_box.jpg 320w,
/posts/boson-frame-grabber-pt3/images/De11m5cV4AAH2np_hu4b3b9a0da469793a0db5610b3338de55_37768_600x0_resize_q75_box.jpg 600w,
/posts/boson-frame-grabber-pt3/images/De11m5cV4AAH2np_hu4b3b9a0da469793a0db5610b3338de55_37768_1200x0_resize_q75_box.jpg 2x" src=/posts/boson-frame-grabber-pt3/images/De11m5cV4AAH2np_hu4b3b9a0da469793a0db5610b3338de55_37768_600x0_resize_q75_box.jpg alt>
</a>
</figure>
<p>I have plans to create an updated version featuring a more power processor capable of handling both the Boson 320 and Boson 640. Stay tuned for more details about this in Part 4!</p>
<p>Here is a teaser! üòâ</p>
<figure class=img-left>
<a href=/posts/boson-frame-grabber-pt3/images/DeLPA6zVwAAU6C-.jpg>
<img srcset="/posts/boson-frame-grabber-pt3/images/DeLPA6zVwAAU6C-_hu0943d98920bfb3e31519888c5f324077_87189_320x0_resize_q75_box.jpg 320w,
/posts/boson-frame-grabber-pt3/images/DeLPA6zVwAAU6C-_hu0943d98920bfb3e31519888c5f324077_87189_600x0_resize_q75_box.jpg 600w,
/posts/boson-frame-grabber-pt3/images/DeLPA6zVwAAU6C-_hu0943d98920bfb3e31519888c5f324077_87189_1200x0_resize_q75_box.jpg 2x" src=/posts/boson-frame-grabber-pt3/images/DeLPA6zVwAAU6C-_hu0943d98920bfb3e31519888c5f324077_87189_600x0_resize_q75_box.jpg alt>
</a>
</figure>
<figure class=img-left>
<a href=/posts/boson-frame-grabber-pt3/images/DeLPA6yVQAAm7Jw.jpg>
<img srcset="/posts/boson-frame-grabber-pt3/images/DeLPA6yVQAAm7Jw_hu3985b99a911a778708e9c812915c2f3b_114308_320x0_resize_q75_box.jpg 320w,
/posts/boson-frame-grabber-pt3/images/DeLPA6yVQAAm7Jw_hu3985b99a911a778708e9c812915c2f3b_114308_600x0_resize_q75_box.jpg 600w,
/posts/boson-frame-grabber-pt3/images/DeLPA6yVQAAm7Jw_hu3985b99a911a778708e9c812915c2f3b_114308_1200x0_resize_q75_box.jpg 2x" src=/posts/boson-frame-grabber-pt3/images/DeLPA6yVQAAm7Jw_hu3985b99a911a778708e9c812915c2f3b_114308_600x0_resize_q75_box.jpg alt>
</a>
</figure>
</div>
<footer class=post-footer>
<ul class=post-tags>
<li><a href=https://gregdavill.github.io/tags/boson/>boson</a></li>
<li><a href=https://gregdavill.github.io/tags/boson-frame-grabber/>boson-frame-grabber</a></li>
<li><a href=https://gregdavill.github.io/tags/thermal/>thermal</a></li>
</ul>
<nav class=paginav>
<a class=prev href=https://gregdavill.github.io/posts/boson-frame-grabber-pt4/>
<span class=title>¬´ Prev Page</span>
<br>
<span>Boson Frame Grabber Part 4</span>
</a>
<a class=next href=https://gregdavill.github.io/posts/boson-frame-grabber-pt2/>
<span class=title>Next Page ¬ª</span>
<br>
<span>Boson Frame Grabber Part 2</span>
</a>
</nav>
</footer>
<div id=hyvor-talk-view></div>
<script type=text/javascript>var palette,HYVOR_TALK_WEBSITE,HYVOR_TALK_CONFIG;dark_palette={accent:"#ffffff",accentText:"#000000",footerHeader:"#1b1818",footerHeaderText:"#cac7c7",box:"#232121",boxText:"#ffffff",boxLightText:"#aaaaaa",backgroundText:"#ffffff"},light_palette={accent:"#659DBD",accentText:"#FFFFFF",footerHeader:"#FAFAFA",footerHeaderText:"#484848",box:"#FFFFFF",boxText:"#111111",boxLightText:"#AAAAAA",backgroundText:"#111111"},palette=light_palette,document.body.className.includes("dark")&&(palette=dark_palette),HYVOR_TALK_WEBSITE=5683,HYVOR_TALK_CONFIG={url:!1,id:'990280e54dbed6d8c282839b3325c148',palette},document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?hyvor_talk.setPalette(light_palette):hyvor_talk.setPalette(dark_palette)})</script>
<script async type=text/javascript src=//talk.hyvor.com/web-api/embed.js></script>
</article>
</main>
<footer class=footer>
<span>&copy; 2021 <a href=https://gregdavill.github.io/>Greg Davill's Projects</a></span>
<span>
Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a>
</span>
</footer>
<a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a>
<script>let menu=document.getElementById('menu');menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script>
<script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script>
<script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script>
<script>document.querySelectorAll('pre > code').forEach(b=>{const c=b.parentNode.parentNode,a=document.createElement('button');a.classList.add('copy-code'),a.innerText='copy';function d(){a.innerText='copied!',setTimeout(()=>{a.innerText='copy'},2e3)}a.addEventListener('click',e=>{if('clipboard'in navigator){navigator.clipboard.writeText(b.textContent),d();return}const a=document.createRange();a.selectNodeContents(b);const c=window.getSelection();c.removeAllRanges(),c.addRange(a);try{document.execCommand('copy'),d()}catch(a){}c.removeRange(a)}),c.classList.contains("highlight")?c.appendChild(a):c.parentNode.firstChild==c||(b.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?b.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(a):b.parentNode.appendChild(a))})</script>
</body>
</html>